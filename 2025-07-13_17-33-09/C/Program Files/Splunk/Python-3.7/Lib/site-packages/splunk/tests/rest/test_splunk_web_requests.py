import unittest
import cherrypy
from splunk.rest.splunk_web_requests import _parse_json_response, _get_settings, is_v2_search_enabled

try:
    from unittest.mock import patch
    from unittest.mock import MagicMock
except ImportError:
    from mock import patch
    from mock import MagicMock

# setup mock response classes to pass to mocks
class MockResponse(object): pass
mock_valid_response = MockResponse()
mock_valid_response.status = 200
mock_invalid_response = MockResponse()
mock_invalid_response.status = 400

class TestParseJSONResponse(unittest.TestCase):
    def test_normalized_stanza(self):
        mock_data = {
            'entry': [
                {
                    'name': 'foo-entry',
                    'content': {
                        'foo': 'bar',
                        'test-norm': '1',
                    }
                }
            ]
        }
        normalized_attributes = _parse_json_response(mock_data, 'foo-entry')
        self.assertEqual(normalized_attributes, {
            'name': 'foo-entry',
            'foo': 'bar',
            'test-norm': True,
        })
    def test_multiple_entries_normalized(self):
        mock_data = {
            'entry': [
                {
                    'name': 'foo-entry',
                    'content': {
                        'foo': 'bar',
                        'test-norm': '1',
                    }
                },
                {
                    'name': 'foo-entry-2',
                    'content': {
                        'foo': 'bar-2',
                        'test-norm': '0',
                    }
                }
            ]
        }
        normalized_attributes = _parse_json_response(mock_data)
        self.assertEqual(normalized_attributes, [{
            'name': 'foo-entry',
            'foo': 'bar',
            'test-norm': True,
        }, {
            'name': 'foo-entry-2',
            'foo': 'bar-2',
            'test-norm': False,
        }])
    def test_invalid_stanza(self):
        mock_data = {
            'entry': [
                {
                    'name': 'foo-entry',
                    'content': {
                        'foo': 'bar',
                        'test-norm': '1',
                    }
                }
            ]
        }
        normalized_attributes = _parse_json_response(mock_data, 'foo-entry-invalid')
        self.assertEqual(normalized_attributes, [])

class TestGetSettings(unittest.TestCase):
    def test_non_json_url(self):
        try:
            settings = _get_settings('/foo', 'general', 'error_message', 'foo_session_key')
            self.assertFalse(True) # should never get here
        except Exception as e:
            self.assertEqual(str(e), 'url "/foo" must request json output.')

    @patch('cherrypy.config.get',
        MagicMock(return_value='some_cached_result'))
    def test_cached_valid_cache_settings(self):
        settings = _get_settings('/foo?output_mode=json', 'general', 'error_message', 'foo_session_key', 'my_cache_key')
        self.assertEqual(settings, 'some_cached_result')

    @patch('cherrypy.config.get',
        MagicMock(return_value=None))
    @patch('splunk.rest.splunk_web_requests._make_get_request',
        MagicMock(return_value=(mock_invalid_response, b'{}')))
    def test_invalid_response(self):
        settings = _get_settings('/foo?output_mode=json', None, 'error_message', 'foo_session_key', 'my_cache_key')
        self.assertEqual(settings, None)

    @patch('cherrypy.config.update')
    @patch('splunk.rest.splunk_web_requests._make_get_request',
        MagicMock(return_value=(mock_valid_response, b'{"entry":[{"name":"foo-entry","content":{"foo":"bar","test-norm": "1"}}]}')))
    def test_success_response_no_cache(self, mock_update):
        settings = _get_settings('/foo?output_mode=json', None, 'error_message', 'foo_session_key')
        self.assertEqual(settings, [{'foo': 'bar', 'test-norm': True, 'name': 'foo-entry'}])
        self.assertEqual(mock_update.call_count, 0)

    @patch('cherrypy.config.update')
    @patch('cherrypy.config.get',
        MagicMock(return_value=None))
    @patch('splunk.rest.splunk_web_requests._make_get_request',
        MagicMock(return_value=(mock_valid_response, b'{"entry":[{"name":"foo-entry","content":{"foo":"bar","test-norm": "1"}}]}')))
    def test_cached_settings_no_cache_exists(self, mock_update):
        settings = _get_settings('/foo?output_mode=json', None, 'error_message', 'foo_session_key', 'my_cache_key')
        self.assertEqual(settings, [{'foo': 'bar', 'test-norm': True, 'name': 'foo-entry'}])
        self.assertEqual(mock_update.call_count, 1)
        mock_update.assert_called_with({'my_cache_key': [{'foo': 'bar', 'test-norm': True, 'name': 'foo-entry'}]})

class SearchV2Tests(unittest.TestCase):
    @patch('splunk.rest.splunk_web_requests._get_web_feature',
           MagicMock(return_value={ "enable_search_v2_endpoint": True }))
    def test_search_v2_enabled(self):
        self.assertTrue(is_v2_search_enabled())

    @patch('splunk.rest.splunk_web_requests._get_web_feature',
           MagicMock(return_value={ "enable_search_v2_endpoint": False }))
    def test_search_v2_disabled(self):
        self.assertFalse(is_v2_search_enabled())

    def test_search_v2_throws_exception(self):
        self.assertRaises(Exception, is_v2_search_enabled())
    
    @patch('splunk.rest.splunk_web_requests._get_web_feature',
           MagicMock(return_value=None))
    def test_search_v2_default(self):
        self.assertTrue(is_v2_search_enabled())

if __name__ == '__main__':
    # exec all tests
    loader = unittest.TestLoader()
    suites = []
    suites.append(loader.loadTestsFromTestCase(SearchV2Tests))
    unittest.TextTestRunner(verbosity=2).run(unittest.TestSuite(suites))

if __name__ == '__main__':
    unittest.main()
