import os
import sys
import logging
import requests

from requests.auth import HTTPBasicAuth
from . exceptions import AppInspectException, AppInspectAuthenticateException, \
                         AppInspectValidateException

logger = logging.getLogger(__name__)

DEFAULT_ENDPOINT = "https://appinspect.splunk.com/v1"
DEFAULT_AUTH_ENDPOINT = "https://api.splunk.com/2.0/rest/login/splunk"
REQUEST_TIMEOUT = 20
ERROR_MESSAGE = {
    "UNAUTHORIZED": "Incorrect username or password for Splunk credentials.",
    "NOT_FOUND": ("This app has not been submitted to AppInspect. "
                  "Submit your app to AppInspect for validation."),
    "FORBIDDEN": ("You are not authorized to install this app. "
                  "You must submit the app to AppInspect, "
                  "and specify the same credentials as those "
                  "used for AppInspect."),
    "IN_PROGRESS": ("AppInspect validation is in progress. "
                    "Try again later"),
    "VALIDATION_FAILED": ("This app has failed AppInspect validation. "
                          "Fix the issues in the report, "
                          "and retry AppInspect validation."),
    "GENERAL_ERROR": ("Unable to retrieve AppInspect validation result. "
                      "Try again later.")
}


class AppInspectClient(object):

    def __init__(self, token, endpoint=DEFAULT_ENDPOINT):
        self.token = "bearer {}".format(token)
        self.endpoint = endpoint
        self.authenticated = True

    @staticmethod
    def authenticate(username, password):
        """https://api.splunk.com/2.0/rest/login/splunk
        """
        url = DEFAULT_AUTH_ENDPOINT
        logger.info("Authenticating via url {}".format(url))

        try:
            response = requests.get(
                url=url,
                auth=HTTPBasicAuth(username=username, password=password)
            )

            if response.status_code == 200:
                token = response.json().get("data").get("token")
                return token
            else:
                logger.exception("Received status code: {} from {}".format(response.status_code, url))
                raise AppInspectAuthenticateException(ERROR_MESSAGE["UNAUTHORIZED"])
        except AppInspectAuthenticateException:
            raise
        except Exception as e:
            logger.exception(str(e))
            raise AppInspectAuthenticateException(message=str(e))

    def get_ping(self):
        """ GET /ping """
        if not self.authenticated:
            raise AppInspectAuthenticateException()
        url = "{}/ping".format(self.endpoint)
        headers = {'Authorization': self.token}
        response = requests.get(url=url, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            raise AppInspectException("Received status code {} from url: {}".format(response.status_code, url))

    def validate(self, app_path, arg_included_tags="", arg_excluded_tags=""):
        """
        Submit app to AppInspect validate API

        :type app_path: string
        :param app_path: app path to be submitted to AppInspect
        :arg_include_tags: included tags to be submitted to AppInspect default -> ""
        :arg_exclude_tags: excluded tags to be submitted to AppInspect default -> ""

        :rtype: string
        :return: AppInspect request id
        """
        if not self.authenticated:
            raise AppInspectAuthenticateException()
        try:
            url = "{}/app/validate".format(self.endpoint)
            headers = { "Authorization": self.token }
            files = {}
            if isinstance(app_path, str):
                files["app_package"] = open(app_path, "rb")
            else:
                files["app_package"] = app_path

            logger.info("Submit app to AppInspect with app: {}".format(app_path))
            response = requests.post(
                url=url,
                headers=headers,
                files=files
            )
            logger.info("AppInspect validate API response status: {}".format(response.status_code))
            if response.status_code == 200:
                result = response.json()
                return result.get("request_id")
            else:
                message = response.json().get("message")
                raise AppInspectValidateException(message=message)
        except AppInspectValidateException:
            raise
        except ValueError:
            # non json content
            raise AppInspectValidateException(
                message="Received response {} for validate API".format(response)
            )
        except Exception as e:
            logger.exception(str(e))
            raise AppInspectValidateException(message=str(e))

    def get_validation_status_response(self, id, included_tags=None):
        """
        Use generated id/sha value to retrieve validation result of the app.

        :type id: string
        :param id: id/sha value of a given app

        :type included_tags: string
        :param included_tags: included_tags for app inspect

        :rtype: object
        :return: app validation status response
        """
        if not self.authenticated:
            raise AppInspectAuthenticateException()

        url = "{}/app/validate/status/{}".format(self.endpoint, id)
        headers = { "Authorization": self.token }

        params = {}
        if included_tags is not None:
            params["included_tags"] = included_tags

        logger.info("Checking validation status with url: {}, params: {}".format(url, params))
        return requests.get(
            url=url,
            params=params,
            headers=headers,
            timeout=REQUEST_TIMEOUT
        )

    def get_validation_status(self, id, included_tags=None):
        """
        Use generated id/sha value to retrieve validation result of the app.

        :type id: string
        :param id: id/sha value of a given app

        :type included_tags: string
        :param included_tags: included_tags for app inspect

        :rtype: string
        :return: app validation status
        """
        if not self.authenticated:
            raise AppInspectAuthenticateException()

        try:
            response = self.get_validation_status_response(id, included_tags)
            if response.status_code != 200:
                raise AppInspectValidateException(message=response.json().get("description"))
            response = response.json()
            logger.info(f"Validation status response for id: {id} is: {response}")
            status = response.get("status")
            if status == "SUCCESS":
                    failure = response.get("info", {}).get("failure")
                    error = response.get("info", {}).get("error")
                    manual_check = response.get("info", {}).get("manual_check")
                    if failure == 0 and error == 0 and manual_check == 0:
                        return "SUCCESS"
                    else:
                        return "FAILURE"
            else:
                return status
        except Exception as exc:
            raise AppInspectException("Failed to fetch status for id: {}; exc: {}".format(id, exc)) from exc

    def get_validation_result(self, id, included_tags=None):
        """
        Use generated id/sha value to retrieve validation result of the app.

        :type id: string
        :param id: id/sha value of a given app

        :type included_tags: string
        :param included_tags: included_tags for app inspect

        :rtype: boolean
        :return: whether the app is validated
        """
        if not self.authenticated:
            raise AppInspectAuthenticateException()

        try:
            response = self.get_validation_status_response(id, included_tags)

            # AppInspect responded with 404 Not Found:
            # id/sha is not matching with any values on AppInspect
            if response.status_code == 404:
                message = ERROR_MESSAGE["NOT_FOUND"]
                logger.exception(message)
                raise AppInspectValidateException(message)

            # AppInspect responded with 403 Forbidden
            # Splunk credentials used to submit app on AppInspect is not
            #   matching with the user that uploads app on stack
            elif response.status_code == 403:
                message = ERROR_MESSAGE["FORBIDDEN"]
                logger.exception(message)
                raise AppInspectValidateException(message)

            # AppInspect responded with 200 Success
            # App can be found on AppInspect via id/sha, but needs further
            #   if check to determine it passes validation
            elif response.status_code == 200:
                content = response.json()

                # App is still pending validation:
                if content.get("status") == "PROCESSING":
                    message = ERROR_MESSAGE["IN_PROGRESS"]
                    logger.exception(message)
                    raise AppInspectValidateException(message)

                # App passed validation only when all cases are TRUE:
                #   response["status"] == "SUCCESS":
                #       app has finished validation
                #   response["info"]["failure"] == 0:
                #       app has no outstanding failures from AppInspect
                #   response["info"]["error"] == 0:
                #       app has no runtime errors from AppInspect
                if content.get("status") == "SUCCESS" and \
                    content.get("info", {}).get("failure") == 0 and \
                    content.get("info", {}).get("error") == 0:
                    logger.info("App with id/sha {} passed validation".format(id))
                    return True
                else:
                    message = ERROR_MESSAGE["VALIDATION_FAILED"]
                    logger.exception(message)
                    raise AppInspectValidateException(message)

            # AppInspect responded with other status code
            else:
                logger.exception(ERROR_MESSAGE["GENERAL_ERROR"])
                raise AppInspectValidateException(ERROR_MESSAGE["GENERAL_ERROR"])

        except AppInspectValidateException:
            raise
        except requests.exceptions.Timeout:
            logger.exception(ERROR_MESSAGE["GENERAL_ERROR"])
            raise AppInspectValidateException(ERROR_MESSAGE["GENERAL_ERROR"])
        except Exception as e:
            logger.exception(str(e))
            raise AppInspectValidateException(message=str(e))

    def get_validation_report(self, request_id, output_mode="text/html", included_tags=None):
        if not self.authenticated:
            raise AppInspectAuthenticateException()
        try:
            url = "{}/app/report/{}".format(self.endpoint, request_id)
            headers = {
                "Authorization": self.token,
                "Content-Type": output_mode
            }

            params = {}
            if included_tags is not None:
                params["included_tags"] = included_tags

            logger.info("Retrieve AppInspect report with url: {}, params: {}".format(url, params))
            response = requests.get(url=url, params=params, headers=headers)

            if response.status_code != 200:
                raise AppInspectValidateException("Failed to fetch AppInspect report")

            return response.text if output_mode == "text/html" else response.json()
        except AppInspectValidateException:
            raise
        except Exception as e:
            logger.exception(str(e))
            raise AppInspectValidateException(message=str(e))
