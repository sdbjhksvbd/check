import os
import tarfile
import tempfile
import configparser
import pytest
import splunk.clilib.bundle_paths as bundle_paths
from splunk import InternalServerError
import json
import shutil
import splunk.clilib.app_package as app_package

class TestMerger(object):

    def setup_method(self, method):
        self.src = tempfile.NamedTemporaryFile(delete=False)
        self.dst = tempfile.NamedTemporaryFile(delete=False)

    def teardown_method(self, method):
        if(self.src and os.path.exists(self.src.name)):
            os.remove(self.src.name)
        if(self.dst and os.path.exists(self.dst.name)):
            os.remove(self.dst.name)

    def generate_file(self, file_type, extension, content_dict):
        file = self.src if file_type=="src" else self.dst
        file.name = file.name + extension
        conf_config = configparser.ConfigParser()
        for key in content_dict:
            conf_config[key] = content_dict[key]
        with open(file.name, 'w') as configfile:
            conf_config.write(configfile)

    @pytest.mark.parametrize(("src_dict", "dst_dict", "dryRun", "extension", "expected_result"), [
        # verifies default/app.conf and local/app.conf can be merged correctly
        # with local settings taking precedence
        (
            {'install' : {'is_configured': 'false', 'state': 'disabled'}},
            {'install': {'is_configured': 'true',
             'state': 'disabled', 'build': '1'},
             'id': {'version': '1.0.0'}},
            False,
            ".conf",
            {'default': {},
             'install': {'is_configured': 'true',
             'state': 'disabled', 'build': '1'},
             'id': {'version': '1.0.0'}}
        ),
        # verifies metadata/default.meta and metadata/local.meta can be merged correctly
        # with local settings taking precedence
        (
            {'props/sendmail/': {'export': 'system'}},
            {'viewstates': {'access': 'read : [ * ], write : [ * ]'},
             'default': {'demo': 'xyz'}},
            False,
            ".meta",
            {'props/sendmail/': {'export': 'system'},
             'viewstates': {'access': 'read : [ * ], write : [ * ]'},
             'default': {'demo': 'xyz'}}
        ),
    ])
    def test_merger(self, src_dict, dst_dict, dryRun, extension, expected_result):
        if src_dict and dst_dict:
            self.generate_file("src", extension, src_dict)
            self.generate_file("dst", extension, dst_dict)
            bundle_paths.Bundle._merger(self.src.name, self.dst.name, dryRun, extension)
            assert os.path.exists(self.dst.name)
            check_default_parser = configparser.ConfigParser()
            check_default_parser.read(self.dst.name)
            # check no contents are missing
            assert len(check_default_parser.sections()) == len(expected_result.keys())
            for sect in check_default_parser.sections():
                print(check_default_parser.items(sect))
                assert sect in expected_result # check no extra contents are present
                # check that all the contents match
                assert expected_result[sect] == dict(check_default_parser.items(sect))


class TestGetAppNameFromTarball(object):

    def setup_method(self,method):
        self.valid_app_conf_content = [
                "[ui]",
                "label=Splunk",
                "[package]",
                "id=test_app",
                "[launcher]",
                "version=1.0.0",
                "author=Splunk",
                "description=Splunk Private App",
                ]

        self.invalid_app_conf_content = [
                "[ui]",
                "label=Splunk",
                "[package]",
                "id=test_app",
                "version=1.0.1",
                "[launcher]",
                "version=1.0.0",
                "author=Splunk",
                "description=Splunk Private App",
                ]

    # test app tar info not not starting './'
    def test_get_app_name_from_tarball_normal_app(self):
        with app_package.generate_app(conf_content=self.valid_app_conf_content,
                                      app_name="test_app"
                                      ) as package:
            app_id = bundle_paths.get_app_name_from_tarball(package, True)
        assert app_id=="test_app0"

    # test app tar info starting with './'
    def test_get_app_name_from_tarball_dot_slash_app(self):
        with app_package.generate_app(conf_content=self.valid_app_conf_content,
                               app_name="test_app",
                               prefix="./"
                               ) as package:
            app_id = bundle_paths.get_app_name_from_tarball(package, True)
        assert app_id=="test_app0"

    # test app tar info having multiple apps
    def test_get_app_name_from_tarball_multiple_apps_true(self):
        expected_error_msg = ("[HTTP 500] Application installation failed because: "
                                      "The archive contains more than one application subdirectory: "
                                      "'test_app0' and 'test_app1'..")
        with app_package.generate_app(conf_content=self.valid_app_conf_content,
                              app_name="test_app",
                              num_apps=2
                              ) as package:
            try:
                app_id = bundle_paths.get_app_name_from_tarball(package, True)
                print(app_id)
            except InternalServerError as exc:
                assert "{}".format(exc) == expected_error_msg

    def test_get_app_name_from_tarball_multiple_apps_false(self):
        with app_package.generate_app(conf_content=self.valid_app_conf_content,
                              app_name="test_app",
                              num_apps=2
                              ) as package:
            app_id = bundle_paths.get_app_name_from_tarball(package, False)
        assert app_id=="test_app0"

    # test app tar info having app with static dependency
    def test_get_app_name_from_tarball_static_dependency_app(self):
        app_manifest_content = {
            "schemaVersion": "2.0.0",
            "info": {
              "title": "MissingIDVersion",
              "id": {
                "group": "null",
                "name": "MissingIDVersion",
                "version": "1.2.0"
              }
            },
            "dependencies": {
              "DependentApp": {
                "version": ">=1.0.0",
                "package": "DependentApp-1.1.0.tar.gz"
              }
            },
            "tasks": [],
            "inputGroups": {
            },
            "incompatibleApps": {
            },
            "platformRequirements": {
            }
        }
        with app_package.generate_app(conf_content=self.valid_app_conf_content,
                                      app_name="test_app",
                                      app_manifest_content=app_manifest_content,
                                      add_dependency=True
                                      ) as package:
            app_id = bundle_paths.get_app_name_from_tarball(package, True)
        assert app_id=="test_app0"

    # test app tar info having an invalid app
    def test_get_app_name_from_tarball_invalid_app(self):
        with app_package.generate_app(conf_content=self.invalid_app_conf_content,
                                      app_name="test_app",
                                      ) as package:
            app_id = bundle_paths.get_app_name_from_tarball(package, True)
        assert app_id=="test_app0"

    def test_get_app_name_from_tarball_error_archive_abs_path(self):
        expected_error_msg = ("[HTTP 500] Application installation failed because: "
                              "The archive would extract to an absolute path..")
        with app_package.generate_app(conf_content=self.valid_app_conf_content,
                                      app_name="test_app",
                                      add_abs_path_dir=True
                                      ) as package:
            try:
                app_id = bundle_paths.get_app_name_from_tarball(package, True)
            except InternalServerError as exc:
                assert "{}".format(exc) == expected_error_msg