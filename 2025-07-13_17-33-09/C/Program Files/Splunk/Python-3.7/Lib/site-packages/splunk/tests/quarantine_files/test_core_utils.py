import unittest
import os
import json
from splunk.quarantine_files import core_utils
from splunk.file_writing_utils import write_path, delete_path
from splunk.quarantine_files.configs.jquery_2_config import EnableJQuery2
from splunk.quarantine_files.configs.bad_imports_config import EnableBadImports

SPLUNK_HOME_PATH = os.path.join(os.environ['SPLUNK_HOME']);
QUARANTINED_FILES_PATH = os.path.join(SPLUNK_HOME_PATH, 'quarantined_files');
MOCK_QUARANTINED_FILES_PATH = os.path.join(SPLUNK_HOME_PATH, 'mock_quarantined_files');

try:
    from unittest.mock import patch
    from unittest.mock import MagicMock
except ImportError:
    from mock import patch
    from mock import MagicMock
class TestSettingChanged(unittest.TestCase):
    def setUp(self):
        self.manifest_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'mock_quarantine_manifest.json')
    def tearDown(self):
        delete_path(MOCK_QUARANTINED_FILES_PATH)
        self.manifest_path = None
    def verify_manifest(self, expected):
        with open(self.manifest_path, 'r') as f:
            actual_manifest = json.load(f)
        self.assertTrue(actual_manifest == expected, 'actual manifest is {}'.format(actual_manifest))
    def test_no_manifest_unrestricted(self):
        write_path(MOCK_QUARANTINED_FILES_PATH)
        expected_should_update = False
        should_update = core_utils.setting_changed('foo', False, self.manifest_path)
        self.assertEqual(should_update, expected_should_update)
        self.verify_manifest({ 'foo': 'not-restricted' })
    def test_no_manifest_restricted(self):
        write_path(MOCK_QUARANTINED_FILES_PATH)
        expected_should_update = True
        should_update = core_utils.setting_changed('foo', True, self.manifest_path)
        self.assertEqual(should_update, expected_should_update)
        self.verify_manifest({ 'foo': 'processing' })
    def test_manifest_new_entry_unrestricted(self):
        write_path(self.manifest_path, json.dumps({}))
        expected_should_update = False
        should_update = core_utils.setting_changed('foo', False, self.manifest_path)
        self.assertEqual(should_update, expected_should_update)
        self.verify_manifest({ 'foo': 'not-restricted' })
    def test_manifest_new_entry_restricted(self):
        write_path(self.manifest_path, json.dumps({}))
        expected_should_update = True
        should_update = core_utils.setting_changed('foo', True, self.manifest_path)
        self.assertEqual(should_update, expected_should_update)
        self.verify_manifest({ 'foo': 'processing' })
    def test_manifest_existing_entry_unchanged(self):
        write_path(self.manifest_path, json.dumps({ 'foo': 'not-restricted' }))
        expected_should_update = False
        should_update = core_utils.setting_changed('foo', False, self.manifest_path)
        self.assertEqual(should_update, expected_should_update)
        self.verify_manifest({ 'foo': 'not-restricted' })
    def test_manifest_existing_entry_changed(self):
        write_path(self.manifest_path, json.dumps({ 'foo': 'not-restricted' }))
        expected_should_update = True
        should_update = core_utils.setting_changed('foo', True, self.manifest_path)
        self.assertEqual(should_update, expected_should_update)
        self.verify_manifest({ 'foo': 'processing' })
    def test_manifest_existing_processing(self):
        write_path(self.manifest_path, json.dumps({ 'foo': 'processing' }))
        expected_should_update = True
        should_update = core_utils.setting_changed('foo', True, self.manifest_path)
        self.assertEqual(should_update, expected_should_update)
        self.verify_manifest({ 'foo': 'processing' })
    def test_manifest_existing_error(self):
        write_path(self.manifest_path, json.dumps({ 'foo': 'error' }))
        expected_should_update = True
        should_update = core_utils.setting_changed('foo', True, self.manifest_path)
        self.assertEqual(should_update, expected_should_update)
        self.verify_manifest({ 'foo': 'processing' })
    def test_corrupted_manifest(self):
        write_path(self.manifest_path, '')
        expected_should_update = True
        should_update = core_utils.setting_changed('foo', True, self.manifest_path)
        self.assertEqual(should_update, expected_should_update)

class TestGetBasePath(unittest.TestCase):
    def test_nonrestricted_base_path(self):
        base_path = core_utils.get_base_path(False)
        expected_path = SPLUNK_HOME_PATH
        self.assertEqual(base_path, expected_path)
    def test_restricted_base_path(self):
        base_path = core_utils.get_base_path(True)
        expected_path = QUARANTINED_FILES_PATH
        self.assertEqual(base_path, expected_path)

class TestGenerateDestinationPaths(unittest.TestCase):
    def test_original_to_quarantined(self):
        paths = [
            os.path.join(SPLUNK_HOME_PATH, 'share', 'splunk', 'search_mrsparkle', 'exposed', 'js', 'foo.js')
        ]
        destination_paths = core_utils.generate_destination_paths(paths)
        expected_path = os.path.join(QUARANTINED_FILES_PATH, 'share', 'splunk', 'search_mrsparkle', 'exposed', 'js', 'foo.js')
        self.assertEqual(len(destination_paths), 1)
        self.assertEqual(destination_paths[0], expected_path)
    def test_quarantined_to_original(self):
        paths = [
            os.path.join(QUARANTINED_FILES_PATH, 'foo.js')
        ]
        destination_paths = core_utils.generate_destination_paths(paths)
        expected_path = os.path.join(SPLUNK_HOME_PATH, 'foo.js')
        self.assertEqual(len(destination_paths), 1)
        self.assertEqual(destination_paths[0], expected_path)
    def test_multiple_files(self):
        paths = [
            os.path.join(SPLUNK_HOME_PATH, 'foo.js'),
            os.path.join(SPLUNK_HOME_PATH, 'bar.js')
        ]
        destination_paths = core_utils.generate_destination_paths(paths)
        expected_paths = [
            os.path.join(QUARANTINED_FILES_PATH, 'foo.js'),
            os.path.join(QUARANTINED_FILES_PATH, 'bar.js'),
        ]
        self.assertEqual(len(destination_paths), 2)
        self.assertEqual(destination_paths[0], expected_paths[0])
        self.assertEqual(destination_paths[1], expected_paths[1])

class TestMoveFiles(unittest.TestCase):
    def setUp(self):
        self.original_paths = []
        self.destination_paths = []
    def tearDown(self):
        for path in self.original_paths:
            delete_path(path)
        for path in self.destination_paths:
            delete_path(path)
        self.destination_paths = None
        delete_path(MOCK_QUARANTINED_FILES_PATH)
    def init_paths(self, original_paths, destination_paths):
        self.original_paths = original_paths
        self.destination_paths = destination_paths
        for path in original_paths:
            write_path(path)
    def test_regular_to_quarantined(self):
        original_path = os.path.join(SPLUNK_HOME_PATH, 'foo.js')
        destination_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'foo.js')
        self.init_paths([original_path], [destination_path])
        core_utils.move_files([original_path], [destination_path], True)
        self.assertFalse(os.path.exists(original_path))
        self.assertTrue(os.path.exists(destination_path))
    def test_quarantined_to_regular(self):
        original_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'foo.js')
        destination_path = os.path.join(SPLUNK_HOME_PATH, 'foo.js')
        self.init_paths([original_path], [destination_path])
        core_utils.move_files([original_path], [destination_path], False)
        self.assertFalse(os.path.exists(original_path))
        self.assertTrue(os.path.exists(destination_path))
    def test_both_paths_exist_restrict_file(self):
        original_path = os.path.join(SPLUNK_HOME_PATH, 'foo.js')
        destination_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'foo.js')
        self.init_paths([original_path, destination_path], [])
        write_path(original_path, 'new')
        write_path(destination_path, 'old')
        core_utils.move_files([original_path], [destination_path], True)
        self.assertFalse(os.path.exists(original_path))
        self.assertTrue(os.path.exists(destination_path))
        with open(destination_path, 'r') as f:
            self.assertEqual(f.read(), 'new')
    def test_both_paths_exist_restrict_dir(self):
        original_path = os.path.join(SPLUNK_HOME_PATH, 'foo')
        destination_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'foo')
        self.init_paths([original_path, destination_path], [])
        core_utils.move_files([original_path], [destination_path], True)
        self.assertFalse(os.path.exists(original_path))
        self.assertTrue(os.path.exists(destination_path))
    def test_both_paths_exist_restore_file(self):
        original_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'foo.js')
        destination_path = os.path.join(SPLUNK_HOME_PATH, 'foo.js')
        self.init_paths([original_path, destination_path], [])
        write_path(original_path, 'old')
        write_path(destination_path, 'new')
        core_utils.move_files([original_path], [destination_path], False)
        self.assertFalse(os.path.exists(original_path))
        self.assertTrue(os.path.exists(destination_path))
        with open(destination_path, 'r') as f:
            self.assertEqual(f.read(), 'new')
    def test_both_paths_exist_restore_dir(self):
        original_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'foo')
        destination_path = os.path.join(SPLUNK_HOME_PATH, 'foo')
        self.init_paths([original_path, destination_path], [])
        core_utils.move_files([original_path], [destination_path], False)
        self.assertFalse(os.path.exists(original_path))
        self.assertTrue(os.path.exists(destination_path))
    def test_move_dir(self):
        base_path = os.path.join(SPLUNK_HOME_PATH, 'foo')
        base_destination_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'foo')
        original_path = os.path.join(base_path)
        destination_path = os.path.join(base_destination_path)
        self.init_paths([original_path], [destination_path])
        original_nested_file_paths = [
            os.path.join(base_path, 'a.js'),
            os.path.join(base_path, 'b.js')
        ]
        destination_nested_file_paths = [
            os.path.join(base_destination_path, 'a.js'),
            os.path.join(base_destination_path, 'b.js')
        ]
        write_path(original_nested_file_paths[0])
        write_path(original_nested_file_paths[1])
        core_utils.move_files([original_path], [destination_path], None)
        self.assertFalse(os.path.exists(original_path))
        self.assertTrue(os.path.exists(destination_path))
        self.assertTrue(os.path.exists(destination_nested_file_paths[0]))
        self.assertTrue(os.path.exists(destination_nested_file_paths[1]))
    def test_file_already_moved_is_success(self):
        original_path = os.path.join(SPLUNK_HOME_PATH, 'foo.js')
        destination_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'foo.js')
        self.init_paths([destination_path], [])
        successfully_moved_files = core_utils.move_files([original_path], [destination_path], True)
        self.assertFalse(os.path.exists(original_path))
        self.assertTrue(os.path.exists(destination_path))
        self.assertTrue(successfully_moved_files)
    def test_no_original_path_is_unsucessful(self):
        original_path = os.path.join(SPLUNK_HOME_PATH, 'foo.js')
        destination_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'foo.js')
        successfully_moved_files = core_utils.move_files([original_path], [destination_path], True)
        self.assertFalse(successfully_moved_files)

class TestCleanQuarantinedDirectory(unittest.TestCase):
    def setUp(self):
        self.quarantined_dir = os.path.join(SPLUNK_HOME_PATH, 'foo')
        write_path(self.quarantined_dir)
    def tearDown(self):
        delete_path(self.quarantined_dir)
    def write_paths(self, paths):
        for path in paths:
            write_path(path)
    def test_single_file_not_cleaned(self):
        paths = [
            os.path.join(self.quarantined_dir, 'foo.js')
        ]
        self.write_paths(paths)
        core_utils.clean_quarantined_directory(self.quarantined_dir)
        self.assertTrue(os.path.exists(paths[0]))
    def test_clean_single_empty_dir(self):
        files = [
            os.path.join(self.quarantined_dir, 'bar')
        ]
        self.write_paths(files)
        core_utils.clean_quarantined_directory(self.quarantined_dir)
        self.assertFalse(os.path.exists(self.quarantined_dir))
    def test_clean_nested_dir(self):
        files = [
            os.path.join(self.quarantined_dir, 'bar', 'charlie', 'delta')
        ]
        self.write_paths(files)
        core_utils.clean_quarantined_directory(self.quarantined_dir)
        self.assertFalse(os.path.exists(self.quarantined_dir))
    def test_partial_clean_nested_dir(self):
        files = [
            os.path.join(self.quarantined_dir, 'bar', 'charlie', 'delta'),
            os.path.join(self.quarantined_dir, 'bar', 'foo.js')
        ]
        self.write_paths(files)
        core_utils.clean_quarantined_directory(self.quarantined_dir)
        self.assertTrue(os.path.exists(files[1]))
        self.assertFalse(os.path.exists(files[0]))
        self.assertFalse(os.path.exists(os.path.join(self.quarantined_dir, 'bar', 'charlie')))

class TestUpdateManifest(unittest.TestCase):
    def setUp(self):
        self.manifest_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'mock_quarantine_manifest.json')
    def tearDown(self):
        delete_path(MOCK_QUARANTINED_FILES_PATH)
        self.manifest_path = None
    def verify_manifest(self, expected):
        with open(self.manifest_path, 'r') as f:
            actual_manifest = json.load(f)
        self.assertTrue(actual_manifest == expected, 'actual manifest is {}'.format(actual_manifest))
    def test_restrict(self):
        write_path(self.manifest_path, json.dumps({}))
        core_utils.update_manifest('foo', False, self.manifest_path)
        self.verify_manifest({ 'foo': 'not-restricted' })
    def test_unrestrict(self):
        write_path(self.manifest_path, json.dumps({}))
        core_utils.update_manifest('foo', True, self.manifest_path)
        self.verify_manifest({ 'foo': 'restricted' })
    def test_update_corrupted_manifest(self):
        write_path(self.manifest_path, '')
        core_utils.update_manifest('foo', True, self.manifest_path)
        self.verify_manifest({ 'foo': 'restricted' })

class TestUpdateRestriction(unittest.TestCase):

    @patch('splunk.rest.splunk_web_requests.get_quarantine_files_settings',
        MagicMock(return_value={ "enable_unsupported_hotlinked_imports": False, "enable_jQuery2": False }))
    @patch('splunk.quarantine_files.core_utils.get_web_settings',
        MagicMock(return_value={ "allow_insecure_libraries_toggle": False }))
    def test_allow_insecure_library_turned_off_with_jquery_off(self):
        jquery_2_config = EnableJQuery2(None)
        bad_imports_config = EnableBadImports(None)
        web_settings = core_utils.get_web_settings()
        core_utils.update_restriction(jquery_2_config, web_settings)
        self.assertTrue(jquery_2_config.should_restrict)
        core_utils.update_restriction(bad_imports_config, web_settings)
        self.assertTrue(bad_imports_config.should_restrict)

    @patch('splunk.rest.splunk_web_requests.get_quarantine_files_settings',
        MagicMock(return_value={ "enable_unsupported_hotlinked_imports": True, "enable_jQuery2": True }))
    @patch('splunk.quarantine_files.core_utils.get_web_settings',
        MagicMock(return_value={ "allow_insecure_libraries_toggle": False }))
    def test_allow_insecure_library_turned_off_with_jquery_on(self):
        jquery_2_config = EnableJQuery2(None)
        bad_imports_config = EnableBadImports(None)
        web_settings = core_utils.get_web_settings()
        core_utils.update_restriction(jquery_2_config, web_settings)
        self.assertTrue(jquery_2_config.should_restrict)
        core_utils.update_restriction(bad_imports_config, web_settings)
        self.assertFalse(bad_imports_config.should_restrict)

    @patch('splunk.rest.splunk_web_requests.get_quarantine_files_settings',
        MagicMock(return_value={ "enable_unsupported_hotlinked_imports": False, "enable_jQuery2": False }))
    @patch('splunk.quarantine_files.core_utils.get_web_settings',
        MagicMock(return_value={ "allow_insecure_libraries_toggle": True }))
    def test_allow_insecure_library_turned_on_with_jquery_off(self):
        jquery_2_config = EnableJQuery2(None)
        bad_imports_config = EnableBadImports(None)
        web_settings = core_utils.get_web_settings()
        core_utils.update_restriction(jquery_2_config, web_settings)
        self.assertTrue(jquery_2_config.should_restrict)
        core_utils.update_restriction(bad_imports_config, web_settings)
        self.assertTrue(bad_imports_config.should_restrict)

    @patch('splunk.rest.splunk_web_requests.get_quarantine_files_settings',
        MagicMock(return_value={ "enable_unsupported_hotlinked_imports": False, "enable_jQuery2": True }))
    @patch('splunk.quarantine_files.core_utils.get_web_settings',
        MagicMock(return_value={ "allow_insecure_libraries_toggle": True }))
    def test_allow_insecure_library_turned_on_with_jquery_on(self):
        jquery_2_config = EnableJQuery2(None)
        bad_imports_config = EnableBadImports(None)
        web_settings = core_utils.get_web_settings()
        core_utils.update_restriction(jquery_2_config, web_settings)
        self.assertFalse(jquery_2_config.should_restrict)
        core_utils.update_restriction(bad_imports_config, web_settings)
        self.assertTrue(bad_imports_config.should_restrict)

class TestLoadManifest(unittest.TestCase):
    def setUp(self):
        self.manifest_path = os.path.join(MOCK_QUARANTINED_FILES_PATH, 'mock_quarantine_manifest.json')
    def tearDown(self):
        delete_path(MOCK_QUARANTINED_FILES_PATH)
        self.manifest_path = None
    def test_load_success(self):
        write_path(self.manifest_path, json.dumps({}))
        (manifest, successfully_loaded_manifest) = core_utils.load_manifest(self.manifest_path)
        self.assertTrue(manifest == {}, 'actual manifest is {}'.format(manifest))
        self.assertTrue(successfully_loaded_manifest)
    def test_load_fail(self):
        write_path(self.manifest_path, '')
        (manifest, successfully_loaded_manifest) = core_utils.load_manifest(self.manifest_path)
        self.assertTrue(manifest == {}, 'actual manifest is {}'.format(manifest))
        self.assertFalse(successfully_loaded_manifest)

if __name__ == '__main__':
    unittest.main()
