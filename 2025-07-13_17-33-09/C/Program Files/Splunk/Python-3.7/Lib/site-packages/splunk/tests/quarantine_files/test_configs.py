import unittest
import os
from splunk.quarantine_files.configs import get_all_configs

try:
    from unittest.mock import patch
    from unittest.mock import MagicMock
except ImportError:
    from mock import patch
    from mock import MagicMock

class TestConfigIntegrity(unittest.TestCase):
    @patch('splunk.rest.splunk_web_requests.get_quarantine_files_settings',
        MagicMock(return_value={ "enable_unsupported_hotlinked_imports": False, "enable_jQuery2": False }))
    def setUp(self):
        self.CONFIGS = get_all_configs.get_all_configs(None)
        self.base_path = os.path.join(os.environ['SPLUNK_HOME'])
    def tearDown(self):
        self.CONFIGS = None
        self.base_path = None
    def test_correct_config_initialization(self):
        for config in self.CONFIGS:
            config_vars = vars(config)
            settings_to_check = ['setting', 'should_restrict']
            for setting in settings_to_check:
                self.assertTrue(setting in config_vars, 'Config {} is missing property {}'.format(config, setting))
    def test_configs_do_not_target_folders(self):
        all_paths = {}
        for config in self.CONFIGS:
            # It is important that we test assuming all settings are restricted at once to find any conflicts
            config.should_restrict = True
            candidate_new_paths = config.get_paths_to_restrict(self.base_path)
            for candidate_path in candidate_new_paths:
                is_dir = os.path.isdir(candidate_path)
                self.assertFalse(
                    is_dir,
                    'Configs cannot contain folders: {}. Unpack directories with config_utils.get_all_files_in_dir_recursive'.format(candidate_path)
                )
    def test_configs_do_not_target_same_file(self):
        all_paths = {}
        for config in self.CONFIGS:
            # It is important that we test assuming all settings are restricted at once to find any conflicts
            config.should_restrict = True
            candidate_new_paths = config.get_paths_to_restrict(self.base_path)
            for candidate_path in candidate_new_paths:
                self.assertTrue(candidate_path not in all_paths,
                    'Restricting path "{}" has already been excluded by a config'.format(candidate_path))
                all_paths[candidate_path] = True

if __name__ == '__main__':
    unittest.main()
