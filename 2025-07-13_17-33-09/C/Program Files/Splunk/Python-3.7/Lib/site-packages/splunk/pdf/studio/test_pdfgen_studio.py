import unittest
import copy
import json

try:
    from unittest.mock import patch
    from unittest.mock import MagicMock
except ImportError:
    from mock import patch
    from mock import MagicMock
import splunk.search
import splunk.rest as rest
import splunk.pdf.studio.pdfgen_studio as pdfgen_studio
from splunk.search import ResultField, ResultFieldValue, Result, RawEvent
from splunk.pdf.test_utils import MockMethod, mock, MockClass, MockJob, Expando
from splunk.pdf.pdfgen_search import InlineSearchManager, SavedSearchManager, PostProcessSearchManager
import splunk.entity as entity
from splunk.pdf.studio.url_utils import getDataURIForExternalImage, extractCSPAndTrustedDomains
import splunk.pdf.availability


def mockInlineSearchEnv(result=None):
    return mock(
        dispatch=MockMethod(splunk.search, "dispatch",
                            result=result if result is not None else MockJob()),
        SearchJob=MockClass(splunk.search, "SearchJob", MockJob)
    )


def createMockServerInfo(product_type='enterprise', version='8.2.2107', instance_type=None, isFree='0'):
    serverInfo = entity.Entity(
        entityPath=['/server', 'info'],
        entityName='serverInfo'
    )
    serverInfo.properties = {
        'product_type': product_type,
        'version': version,
        'instance_type': instance_type,
        'isFree': isFree
    }
    return serverInfo


def createMockUserInfo(username='admin', realname='Administrator', email='changeme@splunk.com'):
    userInfo = entity.Entity(
        entityPath=['/authentication', 'current-context'],
        entityName='currentContext'
    )
    userInfo.properties = {
        'username': username,
        'realname': realname,
        'email': email
    }
    return userInfo

def createMockGenerateRandomId(idPrefix='ds'):
    id = '%s_1' % idPrefix
    return MockMethod(pdfgen_studio, 'generateRandomId', result=id)


class ResultSetMock:
    """
    Mock of splunk.search ResultSet class

    Attributes
    ----------
    results : list of Result type
        iterable list of all results
    fieldOrder : list
        list of fields
        for example, ['field1', 'field2', 'field3']
    """

    def __init__(self, results, fieldOrder):
        self.results = results
        self.fieldOrder = fieldOrder
        self.mode = 'results'

    def __iter__(self):
        return self.results.__iter__()


def createResultFieldValue(value):
    """
    Helper to create a ResultField containing a ResultFieldValue with the given value and defaults.
    """
    return ResultField(fieldValues=[ResultFieldValue(value=value, isHighlighted=True)])


class PDFStudioTest(unittest.TestCase):
    def testParseDataSourceSearchResultsWithOneResultRow(self):
        fieldOrder = ['Host', 'Sourcetype', 'Linecount']
        results = Result(
            {'Host': createResultFieldValue('host1'), 'Sourcetype': createResultFieldValue('sourcetype1'),
             'Linecount': createResultFieldValue('1')})

        resultSet = ResultSetMock(
            results=[results],
            fieldOrder=fieldOrder
        )
        fields, columns = pdfgen_studio.parseDataSourceSearchResults(
            resultSet, fieldOrder)
        self.assertEqual(fields, fieldOrder)
        self.assertEqual(columns, [['host1'], ['sourcetype1'], ['1']])

    def testParseDataSourceSearchResultsWithManyResultRows(self):
        fieldOrder = ['Host', 'Sourcetype', 'Linecount']
        resultsRow1 = Result(
            {'Host': createResultFieldValue('host1'), 'Sourcetype': createResultFieldValue('sourcetype1'),
             'Linecount': createResultFieldValue('1')})
        resultsRow2 = Result(
            {'Host': createResultFieldValue('host2'), 'Sourcetype': createResultFieldValue('sourcetype2'),
             'Linecount': createResultFieldValue('2')})
        resultsRow3 = Result(
            {'Host': createResultFieldValue('host3'), 'Sourcetype': createResultFieldValue('sourcetype3'),
             'Linecount': createResultFieldValue('3')})

        resultSet = ResultSetMock(
            results=[resultsRow1, resultsRow2, resultsRow3],
            fieldOrder=fieldOrder
        )
        fields, columns = pdfgen_studio.parseDataSourceSearchResults(
            resultSet, fieldOrder)
        self.assertEqual(fields, fieldOrder)
        self.assertEqual(columns,
                         [['host1', 'host2', 'host3'], ['sourcetype1', 'sourcetype2', 'sourcetype3'], ['1', '2', '3']])

    def testParseDataSourceSearchResultsWithUnusedFieldsInFieldOrder(self):
        fieldOrder = ['Host', 'Sourcetype', 'Extra1', 'Linecount', 'Extra2']
        results = Result(
            {'Host': createResultFieldValue('host1'), 'Sourcetype': createResultFieldValue('sourcetype1'),
             'Linecount': createResultFieldValue('1')})

        resultSet = ResultSetMock(
            results=[results],
            fieldOrder=fieldOrder
        )
        expectedFields = ['Host', 'Sourcetype', 'Linecount']
        fields, columns = pdfgen_studio.parseDataSourceSearchResults(
            resultSet, fieldOrder)
        self.assertEqual(fields, expectedFields)
        self.assertEqual(columns, [['host1'], ['sourcetype1'], ['1']])

    def testParseDataSourceSearchResultsWithDifferentTypesOfFieldValues(self):
        fieldOrder = ['Host', 'Sourcetype', 'Raw']
        resultsRow1 = Result(
            {'Host': createResultFieldValue('host1'), 'Sourcetype': createResultFieldValue('sourcetype1'),
             'Raw': RawEvent('rawevent1')})
        resultsRow2 = Result(
            {'Host': createResultFieldValue('host2'), 'Sourcetype': createResultFieldValue('sourcetype2'),
             'Raw': RawEvent('rawevent2')})

        resultSet = ResultSetMock(
            results=[resultsRow1, resultsRow2],
            fieldOrder=fieldOrder
        )
        fields, columns = pdfgen_studio.parseDataSourceSearchResults(
            resultSet, fieldOrder)
        self.assertEqual(fields, fieldOrder)
        self.assertEqual(columns, [['host1', 'host2'], [
                         'sourcetype1', 'sourcetype2'], ['rawevent1', 'rawevent2']])

    def testGetDataSourceSearchResultsWithSearchManagerError(self):
        searchManager = None
        resolvedDataSources = {}
        erroredDataSources = {}
        ds = 'ds1'
        expectedErroredDataSources = {
            'ds1': 'Unable to create search.'
        }
        pdfgen_studio.getDataSourceSearchResults(
            searchManager, resolvedDataSources, erroredDataSources, ds, True, {})
        self.assertEqual(erroredDataSources, expectedErroredDataSources)
        self.assertFalse(resolvedDataSources)

    @patch('splunk.pdf.studio.pdfgen_studio.DEFAULT_TIMEOUT', 2)
    def testGetDataSourceSearchResultsWithTimeoutError(self):
        resolvedDataSources = {}
        erroredDataSources = {}
        ds = 'ds1'
        expectedErroredDataSources = {
            'ds1': 'Search timed out after 2 seconds.'
        }
        searchManager = InlineSearchManager(
            'searchCommand', 'earliest', 'latest', 'namespace', 'owner', 'sessionKey')
        dispatch = MockMethod(splunk.search, "dispatch", result=MockJob())
        with mock(dispatch=dispatch):
            pdfgen_studio.getDataSourceSearchResults(
                searchManager, resolvedDataSources, erroredDataSources, ds, True, {})
            self.assertEqual(erroredDataSources, expectedErroredDataSources)
            self.assertFalse(resolvedDataSources)

    def testGetDataSourceSearchResultsSuccessful(self):
        resolvedDataSources = {}
        erroredDataSources = {}
        ds = 'ds1'
        dataSourceDef = {
            'type': 'ds.search',
            'name': 'name for ds1',
            'options': {
                'query': 'index=_internal | stats count',
                'enableSmartSources': True,
            }
        }
        expectedResolvedDataSources = {
            'ds1': {
                'type': 'ds.test',
                'name': 'name for ds1',
                'options': {
                    'data': {
                        'fields': ['count'],
                        'columns': [['50000']]
                    },
                    'enableSmartSources': True,
                    'meta': {},
                }
            }
        }
        mockedSearchResults = ResultSetMock(
            results={'count': '50000'},
            fieldOrder=['count']
        )
        searchManager = MockJob(result=mockedSearchResults)
        parseDataSourceSearchResults = MockMethod(pdfgen_studio, 'parseDataSourceSearchResults',
                                                  result=(['count'], [['50000']]))
        with mock(parseDataSourceSearchResults=parseDataSourceSearchResults):
            pdfgen_studio.getDataSourceSearchResults(
                searchManager, resolvedDataSources, erroredDataSources, ds, True, dataSourceDef)
            self.assertEqual(resolvedDataSources, expectedResolvedDataSources)
            self.assertFalse(erroredDataSources)

    @patch('splunk.pdf.pdfgen_search.InlineSearchManager')
    def testGetSearchManagerWithDsInManagerMap(self, MockInlineSearchManager):
        dataSources = {
            'ds1': {
                'options': {
                    'query': 'index=internal | stats count'
                }
            }
        }
        expectedSearchManager = InlineSearchManager(
            'index=internal | stats count', '-24h', 'now', '', '', '')
        managerMap = {'ds1': expectedSearchManager}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertEqual(searchManager, expectedSearchManager)
        self.assertFalse(MockInlineSearchManager.called)

    def testGetSearchManagerWithNoType(self):
        dataSources = {
            'ds1': {
                'options': {}
            }
        }
        managerMap = {}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertIsNone(searchManager)
        self.assertEqual(managerMap, {'ds1': None})

    def testGetSearchManagerWithDsSearchTypeWithInvalidOptions(self):
        dataSources = {
            'ds1': {
                'type': 'ds.search',
                'options': {}
            }
        }
        managerMap = {}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertIsNone(searchManager)
        self.assertEqual(managerMap, {'ds1': None})

    def testGetSearchManagerWithDsSearchType(self):
        dataSources = {
            'ds1': {
                'type': 'ds.search',
                'options': {
                    'query': 'index=internal | stats count',
                    'queryParameters': {
                        'latest': '-5h'
                    }
                }
            }
        }
        managerMap = {}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertIsInstance(searchManager, InlineSearchManager)
        self.assertEqual(searchManager.searchCommand,
                         'index=internal | stats count')
        self.assertIsNone(searchManager.earliestTime)
        self.assertEqual(searchManager.latestTime, '-5h')
        self.assertTrue('ds1' in managerMap)

    def testGetSearchManagerWithDsSavedSearchTypeWithInvalidOptions(self):
        dataSources = {
            'ds1': {
                'type': 'ds.savedSearch',
                'options': {}
            }
        }
        managerMap = {}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertIsNone(searchManager)
        self.assertEqual(managerMap, {'ds1': None})

    def testGetSearchManagerWithDsSavedSearchType(self):
        dataSources = {
            'ds1': {
                'type': 'ds.savedSearch',
                'options': {
                    'ref': 'saved'
                }
            }
        }
        managerMap = {}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertIsInstance(searchManager, SavedSearchManager)
        self.assertEqual(searchManager.searchName, 'saved')
        self.assertTrue('ds1' in managerMap)

    def testGetSearchManagerWithDsChainTypeWithInvalidQueryOptions(self):
        dataSources = {
            'ds1': {
                'type': 'ds.chain',
                'options': {
                    'extend': 'ds2'
                }
            }
        }
        managerMap = {}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertIsNone(searchManager)
        self.assertEqual(managerMap, {'ds1': None})

    def testGetSearchManagerWithDsChainTypeWithInvalidExtendOptions(self):
        dataSources = {
            'ds1': {
                'type': 'ds.chain',
                'options': {
                    'query': '| where count > 10'
                }
            }
        }
        managerMap = {}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertIsNone(searchManager)
        self.assertEqual(managerMap, {'ds1': None})

    def testGetSearchManagerWithDsChainTypeWithInvalidParentManager(self):
        dataSources = {
            'ds1': {
                'type': 'ds.chain',
                'options': {
                    'query': '| where count > 10',
                    'extend': 'ds2'
                }
            }
        }
        managerMap = {}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertIsNone(searchManager)
        self.assertEqual(managerMap, {'ds1': None, 'ds2': None})

    def testGetSearchManagerWithDsChainTypeWithExistingParentManager(self):
        dataSources = {
            'ds1': {
                'type': 'ds.chain',
                'options': {
                    'query': '| where count > 10',
                    'extend': 'ds2'
                }
            }
        }
        managerMap = {'ds2': InlineSearchManager(
            'index=_internal |  top 100 sourcetype', '-24h', 'now', '', '', '')}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        self.assertIsInstance(searchManager, PostProcessSearchManager)
        self.assertEqual(searchManager.postSearch, '| where count > 10')
        self.assertTrue('ds2' in managerMap)
        self.assertTrue('ds1' in managerMap)

    def testGetSearchManagerWithDsChainTypeWithCreatingParentManager(self):
        dataSources = {
            'ds2': {
                'type': 'ds.search',
                'options': {
                    'query': 'index=_internal |  top 100 sourcetype'
                }
            },
            'ds1': {
                'type': 'ds.chain',
                'options': {
                    'query': '| where count > 10',
                    'extend': 'ds2'
                }
            }
        }
        managerMap = {}
        searchManager = pdfgen_studio.getSearchManager(
            'ds1', dataSources, managerMap, '', '', '')
        parentSearchManager = managerMap['ds2']
        self.assertIsInstance(searchManager, PostProcessSearchManager)
        self.assertEqual(searchManager.postSearch, '| where count > 10')
        self.assertIsInstance(parentSearchManager, InlineSearchManager)

    def testModifyDataSourceSearchesNoDataSources(self):
        definition = {}
        erroredDataSources = pdfgen_studio.modifyDataSourceSearches(
            definition, '', '', '')
        self.assertFalse(erroredDataSources)
        self.assertFalse(definition)

    def testModifyDataSourceSearchesWithNoSearchErrors(self):
        definition = {
            'dataSources': {
                'named_ds': {
                    'name': 'test search name',
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | stats count',
                    }
                },
                'unnamed_ds': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | stats count',
                    }
                }
            }
        }
        expectedOptions = {
            'data': {
                'fields': ['count'],
                'columns': [['50000']]
            },
            'meta': {},
        }
        expectedDefinition = {
            'dataSources': {
                'named_ds': {
                    'type': 'ds.test',
                    'name': 'test search name',
                    'options': expectedOptions
                },
                'unnamed_ds': {
                    'type': 'ds.test',
                    'options': expectedOptions
                }
            }
        }
        mockedSearchResults = ResultSetMock(
            results={'count': '50000'},
            fieldOrder=['count']
        )
        parseDataSourceSearchResults = MockMethod(pdfgen_studio, "parseDataSourceSearchResults",
                                                  result=(['count'], [['50000']]))
        searchManager = MockJob(result=mockedSearchResults)
        getSearchManager = MockMethod(
            pdfgen_studio, "getSearchManager", result=searchManager)
        with mock(parseDataSourceSearchResults=parseDataSourceSearchResults, getSearchManager=getSearchManager):
            erroredDataSources = pdfgen_studio.modifyDataSourceSearches(
                definition, '', '', '')
            self.assertFalse(erroredDataSources)
            self.assertEqual(definition, expectedDefinition)

    def testModifyDataSourceSearchesWithAndWithoutSmartSources(self):
        defaults = {
            'dataSources': {
                'ds.search': {
                    'options': {
                        'enableSmartSources': True,
                    }
                }
            }
        }
        definition = {
            'dataSources': {
                'ds_with_smart_sources': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | stats count',
                        'enableSmartSources': True,
                    }
                },
                'ds_without_smart_sources': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | stats count',
                        'enableSmartSources': False,
                    }
                },
                'ds_with_smart_sources_from_default': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | stats count'
                    }
                }
            },
            'defaults': defaults
        }
        def getExpectedOptions(enableSmartSources):
            return {
                'data': {
                    'fields': ['count'],
                    'columns': [['50000']]
                },
                'enableSmartSources': enableSmartSources,
                'meta': {},
            }
        expectedDefinition = {
            'dataSources': {
                'ds_with_smart_sources': {
                    'type': 'ds.test',
                    'options': getExpectedOptions(enableSmartSources=True),
                },
                'ds_without_smart_sources': {
                    'type': 'ds.test',
                    'options': getExpectedOptions(enableSmartSources=False),
                },
                'ds_with_smart_sources_from_default': {
                    'type': 'ds.test',
                    'options': getExpectedOptions(enableSmartSources=True),
                }
            },
            'defaults': defaults
        }
        mockedSearchResults = ResultSetMock(
            results={'count': '50000'},
            fieldOrder=['count']
        )
        parseDataSourceSearchResults = MockMethod(pdfgen_studio, "parseDataSourceSearchResults",
                                                  result=(['count'], [['50000']]))
        searchManager = MockJob(result=mockedSearchResults)
        getSearchManager = MockMethod(
            pdfgen_studio, "getSearchManager", result=searchManager)
        with mock(parseDataSourceSearchResults=parseDataSourceSearchResults, getSearchManager=getSearchManager):
            erroredDataSources = pdfgen_studio.modifyDataSourceSearches(
                definition, '', '', '')
            self.assertFalse(erroredDataSources)
            self.assertEqual(definition, expectedDefinition)

    def testModifyDataSourceSearchesWithTokenError(self):
        definition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.search',
                    'options': {
                        'query': '$token$'
                    }
                }
            }
        }
        erroredDataSources = pdfgen_studio.modifyDataSourceSearches(
            definition, '', '', '')
        self.assertEqual(erroredDataSources, {
                         'ds1': 'Set token value to render visualization'})
        expectedDefinition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.test',
                    'options': {
                        'error': 'Set token value to render visualization'
                    }
                }
            }
        }
        self.assertEqual(definition, expectedDefinition)

    def testModifyDataSourceSearchesWithSearchCreationError(self):
        definition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'bad search'
                    }
                }
            }
        }
        getSearchManager = MockMethod(
            pdfgen_studio, "getSearchManager", result=None)

        with mock(getSearchManager=getSearchManager):
            erroredDataSources = pdfgen_studio.modifyDataSourceSearches(
                definition, '', '', '')
            self.assertEqual(erroredDataSources, {
                             'ds1': 'Unable to create search.'})
            expectedDefinition = {
                'dataSources': {
                    'ds1': {
                        'type': 'ds.test',
                        'options': {
                            'error': 'Unable to create search.'
                        }
                    }
                }
            }
            self.assertEqual(definition, expectedDefinition)

    @patch('splunk.pdf.studio.pdfgen_studio.DEFAULT_TIMEOUT', 2)
    def testModifyDataSourceSearchesWithSearchTimeout(self):
        definition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | stats count'
                    }
                }
            }
        }

        with mockInlineSearchEnv():
            erroredDataSources = pdfgen_studio.modifyDataSourceSearches(
                definition, '', '', '')
            self.assertEqual(erroredDataSources, {
                             'ds1': 'Search timed out after 2 seconds.'})
            expectedDefinition = {
                'dataSources': {
                    'ds1': {
                        'type': 'ds.test',
                        'options': {
                            'error': 'Search timed out after 2 seconds.'
                        }
                    }
                }
            }
            self.assertEqual(definition, expectedDefinition)

    def testModifyDataSourceSearchesWithDsTest(self):
        definition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.test',
                    'options': {
                        'data': {
                            'columns': [["99.6"], ["98.7"], ["99.4"]],
                            'fields': [{"name": "Alan"}, {"name": "Emily"}, {"name": "Jasmin"}]
                        }
                    }
                }
            }
        }
        expectedDefinition = copy.deepcopy(definition)
        erroredDataSources = pdfgen_studio.modifyDataSourceSearches(
            definition, '', '', '')
        self.assertFalse(erroredDataSources)
        self.assertEqual(definition, expectedDefinition)

    def testModifyBackgroundImageDataURIWithNoBackgroundImage(self):
        definition = {
            'layout': {
                'options': {}
            }
        }
        expectedDefinition = copy.deepcopy(definition)
        pdfgen_studio.modifyBackgroundImageDataURI(definition, 'sessionKey')
        self.assertEqual(definition, expectedDefinition)

    def testModifyBackgroundImageDataURIWithNoURL(self):
        definition = {
            'layout': {
                'options': {
                    'backgroundImage': {}
                }
            }
        }
        expectedDefinition = copy.deepcopy(definition)
        pdfgen_studio.modifyBackgroundImageDataURI(definition, 'sessionKey')
        self.assertEqual(definition, expectedDefinition)

    def testModifyBackgroundImageDataURIWithNoneURL(self):
        definition = {
            'layout': {
                'options': {
                    'display': 'auto-scale',
                    'backgroundImage': {
                        'src': None
                    }
                }
            }
        }
        expectedDefinition = {
            'layout': {
                'options': {
                    'display': 'auto-scale'
                }
            }
        }
        getDataURI = MockMethod(pdfgen_studio, "getDataURI", result=None)
        with mock(getDataURI=getDataURI):
            pdfgen_studio.modifyBackgroundImageDataURI(
                definition, 'sessionKey')
            self.assertTrue(getDataURI.called)
            self.assertEqual(definition, expectedDefinition)

    def testModifyBackgroundImageDataURIWithValidKvstoreURL(self):
        definition = {
            'layout': {
                'options': {
                    'display': 'auto-scale',
                    'backgroundImage': {
                        'src': 'splunk-enterprise-kvstore://123'
                    }
                }
            }
        }
        dataURI = 'validDataURI'
        expectedDefinition = {
            'layout': {
                'options': {
                    'display': 'auto-scale',
                    'backgroundImage': {
                        'src': dataURI
                    }
                }
            }
        }
        getDataURI = MockMethod(pdfgen_studio, "getDataURI", result=dataURI)
        with mock(getDataURI=getDataURI):
            pdfgen_studio.modifyBackgroundImageDataURI(
                definition, 'sessionKey')
            self.assertTrue(getDataURI.called)
            self.assertEqual(definition, expectedDefinition)

    def testModifyBackgroundImageDataURIWithUntrustedUrlExternalIncluded(self):
        definition = {
            'layout': {
                'options': {
                    'backgroundImage': {
                        'src': 'https://www.test.com'
                    }
                }
            }
        }
        expectedDefinition = {
            'layout': {
                'options': {}
            }
        }
        pdfgen_studio.modifyBackgroundImageDataURI(
            definition, 'sessionKey', True, ["none"])
        self.assertEqual(definition, expectedDefinition)

    def testGetDataURIWithNoURL(self):
        self.assertIsNone(pdfgen_studio.getDataURI(
            None, 'collection', 'sessionKey'))

    def testGetDataURIWithRegularUntrustedURL(self):
        expectedDataURI = 'www.splunk.com'
        dataURI = pdfgen_studio.getDataURI(
            expectedDataURI, 'collection', 'sessionKey')
        self.assertIsNone(dataURI)

    @patch('splunk.pdf.studio.pdfgen_studio.getDataURIForExternalImage')
    def testGetDataURIWithExternalImages(self, mockGetDataURIForExternalImage):
        pdfgen_studio.getDataURI(
            'www.splunk.com', 'collection', 'sessionKey', True)
        self.assertTrue(mockGetDataURIForExternalImage.called)

    @patch('splunk.pdf.studio.pdfgen_studio.getDataURIForExternalImage')
    def testGetDataURIWithExternalImagesAndTrustedDomains(self, mockGetDataURIForExternalImage):
        pdfgen_studio.getDataURI(
            'www.splunk.com', 'collection', 'sessionKey', True, ['none'])
        mockGetDataURIForExternalImage.assert_called_with(
            'www.splunk.com', ['none'])

    @patch('splunk.pdf.studio.pdfgen_studio.getDataURIForExternalImage')
    def testGetDataURIWithoutExternalImagesAndTrustedDomains(self, mockGetDataURIForExternalImage):
        pdfgen_studio.getDataURI(
            'www.splunk.com', 'collection', 'sessionKey', False, ['*'])
        self.assertFalse(mockGetDataURIForExternalImage.called)

    def testGetDataURIWithRegularUntrustedURLContainingKvstoreIdentifier(self):
        expectedDataURI = 'www.splunk.com/splunk-enterprise-kvstore://123'
        dataURI = pdfgen_studio.getDataURI(
            expectedDataURI, 'collection', 'sessionKey')
        self.assertIsNone(dataURI)

    def testGetDataURIWithInvalidKvstoreURLRequest(self):
        simpleRequest = MockMethod(rest, "simpleRequest", exception=Exception)
        with mock(simpleRequest=simpleRequest):
            dataURI = pdfgen_studio.getDataURI(
                'splunk-enterprise-kvstore://123', 'collection', 'sessionkey1')
            self.assertTrue(simpleRequest.called)
            self.assertIsNone(dataURI)

    def testGetDataURIWithSuccessfulKvstoreURLRequest(self):
        expectedDataURI = "validDataURI"
        jobResponseBody = b'{"dataURI": "validDataURI"}'
        simpleReq = MockMethod(rest, "simpleRequest", result=(
            Expando(status=200), jobResponseBody))
        with mock(simpleReq=simpleReq):
            dataURI = pdfgen_studio.getDataURI(
                'splunk-enterprise-kvstore://123', 'collection', 'sessionkey1')
            self.assertTrue(simpleReq.called)
            self.assertEqual(dataURI, expectedDataURI)
    
    def testCheckVisualExporterInstalledAndEnabledAppDoesNotExist(self):
        simpleReq = MockMethod(rest, "simpleRequest", exception=Exception)
        with mock(simpleRequest=simpleReq):
            isAppInstalledAndEnabled = pdfgen_studio.checkVisualExporterInstalledAndEnabled('sessionkey1')
            self.assertTrue(simpleReq.called)
            self.assertFalse(isAppInstalledAndEnabled)
    
    def testCheckVisualExporterInstalledAndEnabledAppDisabled(self):
        jobResponseBody =  '{"entry": [{"content": {"disabled": true }}]}'
        simpleReq = MockMethod(rest, "simpleRequest", result=(
            Expando(status=200), jobResponseBody))
        with mock(simpleRequest=simpleReq):
            isAppInstalledAndEnabled = pdfgen_studio.checkVisualExporterInstalledAndEnabled('sessionkey1')
            self.assertTrue(simpleReq.called)
            self.assertFalse(isAppInstalledAndEnabled)
    
    def testCheckVisualExporterInstalledAndEnabledAppExistsAndEnabled(self):
        print("hello world")
        jobResponseBody = '{"entry": [{"content": {"disabled": false }}]}'
        simpleReq = MockMethod(rest, "simpleRequest", result=(
            Expando(status=200), jobResponseBody))
        with mock(simpleRequest=simpleReq):
            isAppInstalledAndEnabled = pdfgen_studio.checkVisualExporterInstalledAndEnabled('sessionkey1')
            self.assertTrue(simpleReq.called)
            self.assertTrue(isAppInstalledAndEnabled)

    def testModifyVizDataURIWhereVizTypeIsNotImageOrSinglevalueicon(self):
        vizName = 'viz1'
        definition = {
            'visualizations': {
                vizName: {
                    'type': 'viz.singlevalue',
                    'options': {},
                    'dataSources': {}
                }
            }
        }
        expectedDefinition = copy.deepcopy(definition)
        pdfgen_studio.modifyVizDataURI(definition, vizName, 'sessionkey1')
        self.assertEqual(definition, expectedDefinition)

    def testModifyVizDataURIWhereVizTypeIsImageWithValidKvstoreURL(self):
        vizName = 'viz1'
        definition = {
            'visualizations': {
                vizName: {
                    'type': 'viz.img',
                    'options': {
                        'src': 'splunk-enterprise-kvstore://123'
                    }
                }
            }
        }
        dataURI = 'validDataURI'
        expectedDefinition = {
            'visualizations': {
                vizName: {
                    'type': 'viz.img',
                    'options': {
                        'src': dataURI
                    }
                }
            }
        }
        getDataURI = MockMethod(pdfgen_studio, "getDataURI", result=dataURI)
        with mock(getDataURI=getDataURI):
            pdfgen_studio.modifyVizDataURI(definition, vizName, 'sessionkey1')
            self.assertTrue(getDataURI.called)
            self.assertEqual(definition, expectedDefinition)

    def testModifyVizDataURIWhereVizTypeIsImageWithNoURL(self):
        vizName = 'viz1'
        definition = {
            'visualizations': {
                vizName: {
                    'type': 'viz.img',
                    'options': {}
                }
            }
        }
        expectedDefinition = copy.deepcopy(definition)
        pdfgen_studio.modifyVizDataURI(definition, vizName, 'sessionkey1')
        self.assertEqual(definition, expectedDefinition)

    def testModifyVizDataURIWhereVizTypeIsSinglevalueiconWithValidKvstoreURL(self):
        vizName = 'viz1'
        definition = {
            'visualizations': {
                vizName: {
                    'type': 'viz.singlevalueicon',
                    'options': {
                        'icon': 'splunk-enterprise-kvstore://123'
                    }
                }
            }
        }
        dataURI = 'validDataURI'
        expectedDefinition = {
            'visualizations': {
                vizName: {
                    'type': 'viz.singlevalueicon',
                    'options': {
                        'icon': dataURI
                    }
                }
            }
        }
        getDataURI = MockMethod(pdfgen_studio, "getDataURI", result=dataURI)
        with mock(getDataURI=getDataURI):
            pdfgen_studio.modifyVizDataURI(definition, vizName, 'sessionkey1')
            self.assertTrue(getDataURI.called)
            self.assertEqual(definition, expectedDefinition)

    def testModifyVizDataURIWhereVizTypeIsSinglevalueiconWithNoURL(self):
        vizName = 'viz1'
        definition = {
            'visualizations': {
                vizName: {
                    'type': 'viz.singlevalueicon',
                    'options': {}
                }
            }
        }
        expectedDefinition = copy.deepcopy(definition)
        pdfgen_studio.modifyVizDataURI(definition, vizName, 'sessionkey1')
        self.assertEqual(definition, expectedDefinition)

    def testModifyVizDataURIWhereVizTypeIsSplunkSinglevalueiconWithNoURL(self):
        vizName = 'viz1'
        existingDataSource = {
            'type': 'ds.test',
            'name': 'name for ds2',
            'options': {
                'data': {
                    'fields': ['count'],
                    'columns': [['50000']]
                },
                'enableSmartSources': True,
                'meta': {},
            }
        }
        definition = {
            'visualizations': {
                vizName: {
                    'type': 'splunk.singlevalueicon',
                    'options': {},
                    'dataSources': {
                        'primary': 'ds_2'
                    }
                }
            },
            'dataSources': {
                'ds_2': existingDataSource
            }
        }
        expectedDefinition = copy.deepcopy(definition)
        pdfgen_studio.modifyVizDataURI(definition, vizName, 'sessionkey1')
        self.assertEqual(definition, expectedDefinition)

    def assertModifyVizDataUriForIconWithUntrustedUrl(self, vizType, includeExternal=True, trustedDomains=['none']):
        vizName = 'viz1'
        existingDataSource = {
            'type': 'ds.test',
            'name': 'name for ds2',
            'options': {
                'data': {
                    'fields': ['count'],
                    'columns': [['50000']]
                },
                'enableSmartSources': True,
                'meta': {},
            }
        }
        definition = {
            'visualizations': {
                vizName: {
                    'type': vizType,
                    'options': {
                        'icon': 'https://google.com',
                        'showValue': True
                    },
                    'dataSources': {
                        'primary': 'ds_2'
                    }
                }
            },
            'dataSources': {
                'ds_2': existingDataSource
            }
        }
        expectedDefinition = copy.deepcopy(definition)
        del expectedDefinition['visualizations'][vizName]['options']['icon']
        pdfgen_studio.modifyVizDataURI(definition, vizName, 'sessionkey1', includeExternal=includeExternal, trustedDomains=trustedDomains)
        self.assertEqual(definition, expectedDefinition)
    
    def assertModifyVizDataUriForImageWithUntrustedUrl(self, vizType, includeExternal=True, trustedDomains=['none']):
        vizName = 'viz1'
        existingDataSource = {
            'type': 'ds.test',
            'name': 'name for ds2',
            'options': {
                'data': {
                    'fields': ['count'],
                    'columns': [['50000']]
                },
                'enableSmartSources': True,
                'meta': {},
            }
        }
        definition = {
            'visualizations': {
                vizName: {
                    'type': vizType,
                    'options': {
                        'src': 'https://google.com',
                        'preserveAspectRatio': True
                    },
                    'dataSources': {
                        'primary': 'ds_2'
                    }
                }
            },
            'dataSources': {
                'ds_2': existingDataSource
            }
        }
        expectedDefinition = copy.deepcopy(definition)
        del expectedDefinition['visualizations'][vizName]['options']['src']
        expectedDefinition['visualizations'][vizName]['dataSources']['primary'] = 'ds_1'
        expectedDefinition['dataSources']['ds_1'] = {
            'type': 'ds.test',
            'options': {
                'error': 'Image not found'
            }
        }
        with createMockGenerateRandomId():
            pdfgen_studio.modifyVizDataURI(definition, vizName, 'sessionkey1', includeExternal=includeExternal, trustedDomains=trustedDomains)
            print('Definition is %s' % definition)
            print('Expected definition is %s' % expectedDefinition)
            self.assertEqual(definition, expectedDefinition)

    def testModifyVizDataUriWhereVizTypeIsSplunkSinglevalueiconWithUntrustedURL(self):
        self.assertModifyVizDataUriForIconWithUntrustedUrl('splunk.singlevalueicon')

    def testModifyVizDataUriWhereVizTypeIsSplunkSinglevalueiconWhileExcludingExternal(self):
        self.assertModifyVizDataUriForIconWithUntrustedUrl('splunk.singlevalueicon', includeExternal=False, trustedDomains=['*'])

    def testModifyVizDataUriWhereVizTypeIsVizSinglevalueiconWithUntrustedURL(self):
        self.assertModifyVizDataUriForIconWithUntrustedUrl('viz.singlevalueicon')

    def testModifyVizDataUriWhereVizTypeIsVizSinglevalueiconWhileExcludingExternal(self):
        self.assertModifyVizDataUriForIconWithUntrustedUrl('viz.singlevalueicon', includeExternal=False, trustedDomains=['*'])

    def testModifyVizDataUriWhereVizTypeIsVizImgWithUntrustedURL(self):
        self.assertModifyVizDataUriForImageWithUntrustedUrl('viz.img')

    def testModifyVizDataUriWhereVizTypeIsVizImgWhileExcludingExternal(self):
        self.assertModifyVizDataUriForImageWithUntrustedUrl('viz.img', includeExternal=False, trustedDomains=['*'])
    
    def testModifyVizDataUriWhereVizTypeIsSplunkImgWithUntrustedURL(self):
        self.assertModifyVizDataUriForImageWithUntrustedUrl('splunk.image')

    def testModifyVizDataUriWhereVizTypeIsSplunkImgWhileExcludingExternal(self):
        self.assertModifyVizDataUriForImageWithUntrustedUrl('splunk.image', includeExternal=False, trustedDomains=['*'])

    def testGetInputValuesWithoutInputs(self):
        inputValues = pdfgen_studio.getInputValues({})
        self.assertFalse(inputValues)

    def testGetInputValuesWithTimeRangeInput(self):
        definition = {
            'inputs': {
                'input1': {
                    'options': {
                        'defaultValue': '-24h , now',
                        'token': 'timeRangeInput'
                    },
                    'type': 'input.timerange'
                },
                'input2': {
                    'options': {
                        'defaultValue': '-2h,-1h',
                        'token': 'timeRangeInput2'
                    },
                    'type': 'input.timerange'
                }
            }
        }
        expectedInputValues = {
            'timeRangeInput.earliest': '-24h',
            'timeRangeInput.latest': 'now',
            'timeRangeInput2.earliest': '-2h',
            'timeRangeInput2.latest': '-1h'
        }
        inputValues = pdfgen_studio.getInputValues(definition)
        self.assertEqual(inputValues, expectedInputValues)

    def testGetInputValuesWithMultipleInputs(self):
        definition = {
            'inputs': {
                'input1': {
                    'options': {
                        'items': [
                            {
                                "label": "None",
                                "value": "none"
                            },
                            {
                                "label": "Option 1",
                                "value": "option1"
                            }
                        ],
                        'defaultValue': 'none',
                        'token': 'dropdownInput'
                    },
                    'type': 'input.dropdown'
                },
                'input2': {
                    'options': {
                        'defaultValue': 0,
                        'token': 'numberInput',
                        'min': 0,
                        'max': 1000,
                        'step': 5
                    },
                    'type': 'input.number',
                    'title': 'Number Input'
                },
                'input3': {
                    'options': {
                        'items': [
                            {
                                'label': 'Option 1',
                                'value': 'option1'
                            },
                            {
                                'label': 'Option 2',
                                'value': 'option2'
                            },
                            {
                                'label': 'Option 3',
                                'value': 'option3'
                            }
                        ],
                        'token': 'multiselectInput',
                        'defaultValue': 'option1,option3'
                    },
                    'type': 'input.multiselect',
                    'title': 'Multiselect Input',
                },
            }
        }
        expectedInputValues = {
            'dropdownInput': 'none',
            'numberInput': 0,
            'multiselectInput': 'option1,option3'
        }
        inputValues = pdfgen_studio.getInputValues(definition)
        self.assertEqual(inputValues, expectedInputValues)

    def testGetInputValuesIgnoresEnvToken(self):
        definition = {
            'inputs': {
                'input1': {
                    'options': {
                        'items': [
                            {
                                "label": "None",
                                "value": "none"
                            },
                            {
                                "label": "Option 1",
                                "value": "option1"
                            }
                        ],
                        'defaultValue': 'user1',
                        'token': 'user',
                        'tokenNamespace': 'env'
                    },
                    'type': 'input.dropdown'
                },
                'input2': {
                    'options': {
                        'defaultValue': 0,
                        'token': 'numberInput',
                        'min': 0,
                        'max': 1000,
                        'step': 5
                    },
                    'type': 'input.number',
                    'title': 'Number Input'
                },
                'input3': {
                    'options': {
                        'items': [
                            {
                                'label': 'Option 1',
                                'value': 'option1'
                            },
                            {
                                'label': 'Option 2',
                                'value': 'option2'
                            },
                            {
                                'label': 'Option 3',
                                'value': 'option3'
                            }
                        ],
                        'token': 'multiselectInput',
                        'defaultValue': 'option1,option3'
                    },
                    'type': 'input.multiselect',
                    'title': 'Multiselect Input',
                },
            }
        }
        expectedInputValues = {
            'numberInput': 0,
            'multiselectInput': 'option1,option3'
        }
        inputValues = pdfgen_studio.getInputValues(definition)
        self.assertEqual(inputValues, expectedInputValues)

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo',
           MagicMock(return_value=createMockServerInfo(instance_type='cloud')))
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo',
           MagicMock(return_value=createMockUserInfo(realname='', email='')))
    def testGetEnvironmentTokensCloud(self):
        expected_tokens = {
            'env:user': 'admin',
            'env:user_realname': '',
            'env:user_email': '',
            'env:instance_type': 'cloud',
            'env:is_cloud': 'true',
            'env:is_enterprise': 'true',
            'env:product': 'enterprise',
            'env:version': '8.2.2107',
            'env:app': 'search',
            'env:page': 'dash'
        }
        self.assertEqual(
            pdfgen_studio.getEnvironmentTokens(
                '', namespace='search', dashboardName='dash'),
            expected_tokens
        )

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo',
           MagicMock(return_value=createMockServerInfo(isFree='1')))
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo',
           MagicMock(return_value=createMockUserInfo(realname='', email='')))
    def testGetEnvironmentTokensFree(self):
        expected_tokens = {
            'env:user': 'admin',
            'env:user_realname': '',
            'env:user_email': '',
            'env:is_enterprise': 'true',
            'env:is_free': 'true',
            'env:product': 'enterprise',
            'env:version': '8.2.2107',
            'env:app': 'search',
            'env:page': 'dash'
        }
        self.assertEqual(
            pdfgen_studio.getEnvironmentTokens(
                '', namespace='search', dashboardName='dash'),
            expected_tokens
        )

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo',
           MagicMock(return_value=createMockServerInfo(isFree='1', product_type='lite_free')))
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo',
           MagicMock(return_value=createMockUserInfo(realname='', email='')))
    def testGetEnvironmentTokensLiteFree(self):
        expected_tokens = {
            'env:user': 'admin',
            'env:user_realname': '',
            'env:user_email': '',
            'env:is_lite_free': 'true',
            'env:is_free': 'true',
            'env:product': 'lite_free',
            'env:version': '8.2.2107',
            'env:app': 'search',
            'env:page': 'dash'
        }
        self.assertEqual(
            pdfgen_studio.getEnvironmentTokens(
                '', namespace='search', dashboardName='dash'),
            expected_tokens
        )

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo',
           MagicMock(return_value=createMockServerInfo(product_type='lite')))
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo',
           MagicMock(return_value=createMockUserInfo(realname='', email='')))
    def testGetEnvironmentTokensLite(self):
        expected_tokens = {
            'env:user': 'admin',
            'env:user_realname': '',
            'env:user_email': '',
            'env:is_lite': 'true',
            'env:product': 'lite',
            'env:version': '8.2.2107',
            'env:app': 'search',
            'env:page': 'dash'
        }
        self.assertEqual(
            pdfgen_studio.getEnvironmentTokens(
                '', namespace='search', dashboardName='dash'),
            expected_tokens
        )

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo',
           MagicMock(return_value=createMockServerInfo(product_type='hunk')))
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo',
           MagicMock(return_value=createMockUserInfo(realname='', email='')))
    def testGetEnvironmentTokensHunk(self):
        expected_tokens = {
            'env:user': 'admin',
            'env:user_realname': '',
            'env:user_email': '',
            'env:is_hunk': 'true',
            'env:product': 'hunk',
            'env:version': '8.2.2107',
            'env:app': 'search',
            'env:page': 'dash'
        }
        self.assertEqual(
            pdfgen_studio.getEnvironmentTokens(
                '', namespace='search', dashboardName='dash'),
            expected_tokens
        )

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo',
           MagicMock(return_value=createMockServerInfo(instance_type=None)))
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo',
           MagicMock(return_value=createMockUserInfo(realname='Administrator', email='changeme@example.com')))
    def testGetEnvironmentTokensNoInstanceType(self):
        expected_tokens = {
            'env:user': 'admin',
            'env:user_realname': 'Administrator',
            'env:user_email': 'changeme@example.com',
            'env:is_enterprise': 'true',
            'env:product': 'enterprise',
            'env:version': '8.2.2107',
            'env:app': 'search',
            'env:page': 'dash'
        }
        self.assertEqual(
            pdfgen_studio.getEnvironmentTokens(
                '', namespace='search', dashboardName='dash'),
            expected_tokens
        )

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo',
           MagicMock(return_value=createMockServerInfo(instance_type=None, product_type='bogus')))
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo',
           MagicMock(return_value=createMockUserInfo(realname='Administrator', email='changeme@example.com')))
    def testGetEnvironmentTokensInvalidProductType(self):
        expected_tokens = {
            'env:user': 'admin',
            'env:user_realname': 'Administrator',
            'env:user_email': 'changeme@example.com',
            'env:product': 'bogus',
            'env:version': '8.2.2107',
            'env:app': 'search',
            'env:page': 'dash'
        }
        self.assertEqual(
            pdfgen_studio.getEnvironmentTokens(
                '', namespace='search', dashboardName='dash'),
            expected_tokens
        )

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo')
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo')
    def testFetchEnvironmentTokenError(self, serverInfoMock, userInfoMock):
        serverInfoMock.side_effect = Exception('failed to get server info')
        userInfoMock.side_effect = Exception('failed to get user info')
        expected_tokens = {
            'env:app': 'search',
            'env:page': 'dash'
        }
        self.assertEqual(
            pdfgen_studio.getEnvironmentTokens(
                '', namespace='search', dashboardName='dash'),
            expected_tokens
        )

    def testGetInputValuesWithoutDefaultValue(self):
        definition = {
            'inputs': {
                'input1': {
                    'options': {
                        'token': 'noDefaultInput'
                    },
                    'type': 'input.text'
                }
            }
        }
        inputValues = pdfgen_studio.getInputValues(definition)
        self.assertFalse(inputValues)

    def testReplaceInputTokensNoDataSourcesOrVisualizations(self):
        inputs = {
            'input1': {
                'options': {
                    'token': 'token1',
                    'defaultValue': 3
                },
                'type': 'input.text'
            }
        }
        definition = {
            'dataSources': {},
            'inputs': inputs
        }
        expectedDefinition = {
            'dataSources': {},
            'inputs': inputs,
        }
        pdfgen_studio.replaceTokens(definition, '', '', '')
        self.assertEqual(definition, expectedDefinition)

    def testReplaceInputTokensNoInputValues(self):
        dataSources = {
            'ds1': {
                'type': 'ds.search',
                'options': {
                    'query': 'index=_internal | head $number$',
                    'queryParameters': {
                        'earliest': '$timeRangeInput.earliest$',
                        'latest': '$timeRangeInput.latest$'
                    }
                }
            }
        }
        definition = {
            'dataSources': dataSources
        }
        expectedDefinition = copy.deepcopy(definition)
        pdfgen_studio.replaceTokens(definition, '', '', '')
        self.assertEqual(definition, expectedDefinition)

    def testReplaceInputTokensInDataSourcesVisualizationsAndDefaults(self):
        inputs = {
            'input1': {
                'options': {
                    'defaultValue': 3,
                    'token': 'number',
                },
                'type': 'input.number',
                'title': 'Number Input'
            },
            'input2': {
                'options': {
                    'token': 'vizOverlay',
                    'defaultValue': 'none'
                },
                'type': 'input.text'
            },
            'input3': {
                'options': {
                    'defaultValue': '-24h , now',
                    'token': 'timeRangeInput'
                },
                'type': 'input.timerange'
            }
        }
        definition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | head $number$',
                        'queryParameters': {
                            'earliest': '$timeRangeInput.earliest$',
                            'latest': '$timeRangeInput.latest$'
                        }
                    }
                }
            },
            'visualizations': {
                'viz1': {
                    'type': 'viz.table',
                    'options': {
                        'dataOverlayMode': '$vizOverlay$',
                        'count': '$number$'
                    }
                }
            },
            'defaults': {
                'dataSources': {
                    'ds.search': {
                        'options': {
                            'queryParameters': {
                                'latest': '$timeRangeInput.latest$',
                                'earliest': '$timeRangeInput.earliest$'
                            }
                        }
                    }
                }
            },
            'inputs': inputs
        }
        expectedDefinition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | head 3',
                        'queryParameters': {
                            'earliest': '-24h',
                            'latest': 'now'
                        }
                    }
                }
            },
            'visualizations': {
                'viz1': {
                    'type': 'viz.table',
                    'options': {
                        'dataOverlayMode': 'none',
                        'count': 3
                    }
                }
            },
            'defaults': {
                'dataSources': {
                    'ds.search': {
                        'options': {
                            'queryParameters': {
                                'earliest': '-24h',
                                'latest': 'now'
                            }
                        }
                    }
                }
            },
            'inputs': inputs
        }
        pdfgen_studio.replaceTokens(definition, '', '', '')
        self.assertEqual(definition, expectedDefinition)

    def testReplaceInputTokensWhereInputIsMissingDefaultValues(self):
        inputs = {
            'input1': {
                'options': {
                    'token': 'number',
                },
                'type': 'input.number'
            },
            'input2': {
                'options': {
                    'token': 'vizOverlay',
                    'defaultValue': 'none'
                },
                'type': 'input.text'
            }
        }
        definition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | head $number$'
                    }
                }
            },
            'visualizations': {
                'viz1': {
                    'type': 'viz.table',
                    'options': {
                        'dataOverlayMode': '$vizOverlay$',
                        'count': '$number$'
                    }
                }
            },
            'inputs': inputs
        }
        expectedDefinition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.search',
                    'options': {
                        'query': 'index=_internal | head $number$'
                    }
                }
            },
            'visualizations': {
                'viz1': {
                    'type': 'viz.table',
                    'options': {
                        'dataOverlayMode': 'none',
                        'count': '$number$'
                    }
                }
            },
            'inputs': inputs
        }
        pdfgen_studio.replaceTokens(definition, '', '', '')
        self.assertEqual(definition, expectedDefinition)

    def testReplaceInputTokensWithStringEscapes(self):
        inputs = {
            'input1': {
                'options': {
                    'token': 'tokenWithString',
                    'defaultValue': '"none"'
                },
                'type': 'input.text'
            },
            'input2': {
                'options': {
                    'token': 'number',
                    'defaultValue': 3
                },
                'type': 'input.number'
            },
        }
        definition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.search',
                    'options': {
                        'query1': 'index=_internal | head $tokenWithString$',
                        'query2': 'index=_internal | head "$tokenWithString$"',
                        'query3': 'index=_internal | head "$number$"'
                    }
                }
            },
            'visualizations': {},
            'inputs': inputs
        }
        expectedDefinition = {
            'dataSources': {
                'ds1': {
                    'type': 'ds.search',
                    'options': {
                        'query1': 'index=_internal | head "none"',
                        'query2': 'index=_internal | head ""none""',
                        'query3': 'index=_internal | head "3"'
                    }
                }
            },
            'visualizations': {},
            'inputs': inputs
        }
        pdfgen_studio.replaceTokens(definition, '', '', '')
        self.assertEqual(definition, expectedDefinition)

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo',
           MagicMock(return_value=createMockServerInfo(instance_type=None)))
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo',
           MagicMock(return_value=createMockUserInfo(realname='Administrator', email='changeme@example.com')))
    def testReplaceEnvironmentTokensInDataSourcesVisualizationsAndDefaults(self):
        definition = {
            "visualizations": {
                "viz_akzQBkrT": {
                    "type": "viz.line",
                    "dataSources": {
                        "primary": "ds_geoEeTAF"
                    },
                    "title": "Usage for $env:user_realname$ ($env:user$) in product $env:product$"
                }
            },
            "dataSources": {
                "ds_geoEeTAF": {
                    "type": "ds.search",
                    "options": {
                        "query": "index=_internal user = $env:user$ \n| timechart count"
                    },
                    "name": "Search_1"
                }
            },
            "defaults": {
                "visualizations": {
                    "global": {
                        "showLastUpdated": "$env:is_enterprise$"
                    }
                }
            }
        }

        expectedDefinition = {
            "visualizations": {
                "viz_akzQBkrT": {
                    "type": "viz.line",
                    "dataSources": {
                        "primary": "ds_geoEeTAF"
                    },
                    "title": "Usage for Administrator (admin) in product enterprise"
                }
            },
            "dataSources": {
                "ds_geoEeTAF": {
                    "type": "ds.search",
                    "options": {
                        "query": "index=_internal user = admin \n| timechart count"
                    },
                    "name": "Search_1"
                }
            },
            "defaults": {
                "visualizations": {
                    "global": {
                        "showLastUpdated": "true"
                    }
                }
            }
        }

        pdfgen_studio.replaceTokens(definition, '', '', '')
        self.assertEqual(definition, expectedDefinition)

    @patch('splunk.pdf.studio.pdfgen_studio.getServerInfo',
           MagicMock(return_value=createMockServerInfo(product_type='hunk')))
    @patch('splunk.pdf.studio.pdfgen_studio.getUserInfo',
           MagicMock(return_value=createMockUserInfo(realname='Administrator', email='changeme@example.com')))
    def testReplaceEnvironmentTokensSomeNotDefined(self):
        definition = {
            "visualizations": {
                "viz_akzQBkrT": {
                    "type": "viz.line",
                    "dataSources": {},
                    "title": "is_enterprise: $env:is_enterprise$, is_hunk: $env:is_hunk$"
                }
            },
            "dataSources": {},
            "defaults": {}
        }

        expectedDefinition = {
            "visualizations": {
                "viz_akzQBkrT": {
                    "type": "viz.line",
                    "dataSources": {},
                    "title": "is_enterprise: $env:is_enterprise$, is_hunk: true"
                }
            },
            "dataSources": {},
            "defaults": {}
        }

        pdfgen_studio.replaceTokens(definition, '', '', '')
        self.assertEqual(definition, expectedDefinition)

    def hasTokenTrue(self):
        viz = {
            'type': 'viz.table',
            'options': {
                'count': '$number$'
            }
        }
        self.assertTrue(pdfgen_studio.hasToken(json.dumps(viz)))

    def hasTokenTrueWithinString(self):
        ds = {
            'type': 'ds.search',
            'options': {
                'query': 'index=_internal | head $number$ | more search'
            }
        }
        self.assertTrue(pdfgen_studio.hasToken(json.dumps(ds)))

    def hasTokenTrueForMultipleTokens(self):
        ds = {
            'type': 'ds.search',
            'options': {
                'query': 'index=_internal | head $number$',
                'test': '$anotherToken$'
            }
        }
        self.assertTrue(pdfgen_studio.hasToken(json.dumps(ds)))

    def hasTokenFalseIfNoTokens(self):
        viz = {
            'type': 'viz.table',
            'options': {
                'count': 3
            }
        }
        self.assertFalse(pdfgen_studio.hasToken(json.dumps(viz)))

    def hasTokenFalseSingleDollarSign(self):
        viz = {
            'type': 'viz.table',
            'options': {
                'count': '$4'
            }
        }
        self.assertFalse(pdfgen_studio.hasToken(json.dumps(viz)))

    def testMergeOptionsBothEmpty(self):
        self.assertEqual({}, pdfgen_studio.mergeOptions({}, {}))

    def testMergeOption1Empty(self):
        options2 = {"a": 1}
        self.assertEqual(options2, pdfgen_studio.mergeOptions({}, options2))

    def testMergeOption2Empty(self):
        options1 = {"a": 1}
        self.assertEqual(options1, pdfgen_studio.mergeOptions(options1, {}))

    def testMergeOption2Empty(self):
        options1 = {"a": 1}
        self.assertEqual(options1, pdfgen_studio.mergeOptions(options1, {}))

    def testMergeOptionsNoOverlap(self):
        options1 = {"a": 1, "b": 2}
        options2 = {"c": 3, "d": 4}
        expectedMergedOptions = {"a": 1, "b": 2, "c": 3, "d": 4}
        self.assertEqual(expectedMergedOptions,
                         pdfgen_studio.mergeOptions(options1, options2))

    def testMergeOptionsWithOverlapAndOriginalOptionsNotModified(self):
        options1 = options1after = {"a": 1, "b": 2}
        options2 = options2after = {"a": 2, "d": 4}
        expectedMergedOptions = {"a": 1, "b": 2, "d": 4}
        self.assertEqual(expectedMergedOptions,
                         pdfgen_studio.mergeOptions(options1, options2))
        self.assertEqual(options1, options1after)
        self.assertEqual(options2, options2after)

    def testGetMergedDefaultOptionsForDataSourceTypeNoDefaults(self):
        self.assertEqual(
            {}, pdfgen_studio.getMergedDefaultOptionsForDataSourceType({}, 'ds.search'))

    def testGetMergedDefaultOptionsForDataSourceTypeNoType(self):
        self.assertEqual(
            {}, pdfgen_studio.getMergedDefaultOptionsForDataSourceType({"a": 1}, None))

    def testGetMergedDefaultOptionsForDataSourceTypeWithoutTypeSpecificOptions(self):
        defaults = {
            'dataSources': {
                'global': {
                    'options': {
                        'foo': 'bar'
                    }
                },
                'ds.other': {
                    'options': {
                        'foo': 'other'
                    }
                }
            }
        }
        dataSourceType = 'ds.example'
        expectedDefaultOptions = {'foo': 'bar'}
        defaultOptions = pdfgen_studio.getMergedDefaultOptionsForDataSourceType(
            defaults, dataSourceType)
        self.assertEqual(expectedDefaultOptions, defaultOptions)

    def testGetMergedDefaultOptionsForDataSourceTypeWithMergedDefaults(self):
        defaults = {
            'dataSources': {
                'global': {
                    'options': {
                        'foo': 'bar',
                        'foo2': 'apple'
                    }
                },
                'ds.example': {
                    'options': {
                        'foo': 'banana'
                    }
                }
            }
        }
        dataSourceType = 'ds.example'
        expectedDefaultOptions = {'foo': 'banana', 'foo2': 'apple'}
        defaultOptions = pdfgen_studio.getMergedDefaultOptionsForDataSourceType(
            defaults, dataSourceType)
        self.assertEqual(expectedDefaultOptions, defaultOptions)

    def testGetMergedDefaultOptionsForDataSourceTypeRemoveQuery(self):
        defaults = {
            'dataSources': {
                'global': {
                    'options': {
                        'foo': 'bar',
                        'query': 'index=internal | head 2'
                    }
                },
                'ds.example': {
                    'options': {
                        'query': 'index=internal | head 3'
                    }
                }
            }
        }
        dataSourceType = 'ds.example'
        expectedDefaultOptions = {'foo': 'bar'}
        defaultOptions = pdfgen_studio.getMergedDefaultOptionsForDataSourceType(
            defaults, dataSourceType)
        self.assertEqual(expectedDefaultOptions, defaultOptions)

    @patch('splunk.pdf.studio.pdfgen_studio.getMergedDefaultOptionsForDataSourceType')
    def testGetMergedOptionsForDataSourceWithExistingMergedDefaultOptions(self, mock_method):
        dataSource = {
            'type': 'ds.search',
            'options': {'a': 2}
        }
        mergedDefaultOptions = {'ds.search': {'a': 1, 'b': 2, 'c': 3}}
        defaults = {}
        expectedMergedOptions = {'a': 2, 'b': 2, 'c': 3}
        self.assertEqual(expectedMergedOptions,
                         pdfgen_studio.getMergedOptionsForDataSource(dataSource, mergedDefaultOptions, defaults, 'dsName'))
        self.assertFalse(mock_method.called)

    def testGetMergedOptionsForDataSourceGetMergedDefaultOptions(self):
        dataSource = {
            'type': 'ds.search',
            'options': {'a': 3, 'c': 4, 'e': 5}
        }
        mergedDefaultOptions = {'ds.test': {'a': 1}}
        defaults = {
            'dataSources': {
                'global': {'options': {'a': 2, 'b': 2, 'd': 2}},
                'ds.test': {'options': {'a': 1}},
                'ds.search': {'options': {'a': 1, 'b': 1, 'c': 1}},
            }
        }
        expectedMergedOptions = {'a': 3, 'b': 1, 'c': 4, 'd': 2, 'e': 5}
        self.assertEqual(expectedMergedOptions,
                         pdfgen_studio.getMergedOptionsForDataSource(dataSource, mergedDefaultOptions, defaults, 'dsName'))
        
    def testReplaceVizDataSourceWithErrorForVizWithNoExistingDS(self):
        definition = {
            'visualizations': {
                'viz_1': {
                    'type': 'splunk.image',
                    'options': {},
                }
            }
        }

        expectedDefinition = {
            'visualizations': {
                'viz_1': {
                    'type': 'splunk.image',
                    'options': {},
                    'dataSources': {
                        'primary': 'ds_1'
                    }
                }
            },
            'dataSources': {
                'ds_1': {
                    'type': 'ds.test',
                    'options': {
                        'error': 'Test error'
                    }
                }
            }
        }

        with createMockGenerateRandomId():
            pdfgen_studio.replaceVizDataSourceWithError(
                definition, 'viz_1', 'Test error')
            self.assertEqual(expectedDefinition, definition)

    def testReplaceVizDataSourceWithErrorForVizWithExistingDS(self):
        definition = {
            'visualizations': {
                'viz_1': {
                    'type': 'splunk.image',
                    'options': {},
                    'dataSources': {
                        'primary': 'ds_existing'
                    }
                }
            },
            'dataSources': {
                'ds_existing': {
                    'type': 'ds.test',
                    'options': {}
                }
            }
        }

        expectedDefinition = {
            'visualizations': {
                'viz_1': {
                    'type': 'splunk.image',
                    'options': {},
                    'dataSources': {
                        'primary': 'ds_1'
                    }
                }
            },
            'dataSources': {
                'ds_existing': {
                    'type': 'ds.test',
                    'options': {}
                },
                'ds_1': {
                    'type': 'ds.test',
                    'options': {
                        'error': 'Test error'
                    }
                }
            }
        }

        with createMockGenerateRandomId():
            pdfgen_studio.replaceVizDataSourceWithError(definition, 'viz_1', 'Test error')
            self.assertEqual(expectedDefinition, definition)

    testDashboardDefinition = """
    <dashboard version="2" theme="light" >
        <label>test</label>
        <definition>
            <![CDATA[
                {"visualizations":{"viz_2qVEHSGc":{"type":viz.img,"options":{"preserveAspectRatio":true}}}
            ]]>
        </definition>
        <assets>
            <![CDATA[{}]]>
        </assets>
    </dashboard>
        """
    testDashboardName = 'test_studio_dash'
    @patch('splunk.pdf.availability.is_studio_dashboard_scheduled_export_enabled',
           MagicMock(return_value=True))
    @patch('splunk.pdf.studio.pdfgen_studio.checkVisualExporterInstalledAndEnabled',
           MagicMock(return_value=True))
    @patch('splunk.pdf.studio.pdfgen_studio.get_dashboards_csp_settings',
           MagicMock(return_value=None))
    @patch('splunk.pdf.studio.pdfgen_studio.extractCSPAndTrustedDomains',
           MagicMock(return_value=('', None)))
    def testConvertDashboardToPdfContentInvalidDashboardDefinition(self):
        invalidDefinition = """
        <dashboard version="2" theme="light" >
            <label>test</label>
            <definition>
                <![CDATA[
                    {"visualizations":{viz_2qVEHSGc:{"type":viz.img,"options":{"preserveAspectRatio":true}},"options":{"preserveAspectRatio":true},"eventHandlers":[],"globalInputs":[]}}
                ]]>
            </definition>
            <assets>
                <![CDATA[{}]]>
            </assets>
        </dashboard>
                """
        studioErrors = []
        expectedErrors = [pdfgen_studio.INVALID_DEFINITION_ERROR_MSG % self.testDashboardName]

        self.assertFalse(pdfgen_studio.convertDashboardToPdfContent(
            'sessionKey', 'namespace', 'owner', invalidDefinition, self.testDashboardName, studioErrors))
        self.assertEqual(studioErrors, expectedErrors)


    @patch('splunk.pdf.availability.is_studio_dashboard_scheduled_export_enabled',
           MagicMock(return_value=False))
    def testConvertDashboardToPdfContentFeatureFlagNotSet(self):
        studioErrors = []
        expectedErrors = [pdfgen_studio.FEATURE_FLAG_ERROR_MSG % self.testDashboardName]
        self.assertFalse(pdfgen_studio.convertDashboardToPdfContent(
            'sessionKey', 'namespace', 'owner', self.testDashboardDefinition, self.testDashboardName, studioErrors))
        self.assertEqual(studioErrors, expectedErrors)
    
    @patch('splunk.pdf.availability.is_studio_dashboard_scheduled_export_enabled',
           MagicMock(return_value=True))
    @patch('splunk.pdf.studio.pdfgen_studio.checkVisualExporterInstalledAndEnabled',
           MagicMock(return_value=False))
    def testConvertDashboardToPdfContentAppNotInstalledOrEnabled(self):
        studioErrors = []
        expectedErrors = [pdfgen_studio.VISUAL_EXPORTER_ERROR_MSG % self.testDashboardName]
        self.assertFalse(pdfgen_studio.convertDashboardToPdfContent(
            'sessionKey', 'namespace', 'owner', self.testDashboardDefinition, self.testDashboardName, studioErrors))
        self.assertEqual(studioErrors, expectedErrors)

if __name__ == '__main__':
    unittest.main()
