# Defines a safe version of `etree` by not parsing XML external entities

# This replaces defusedxml which, while useful for wrapping ElementTree and
# other XML libraries, has deprecated its `defusedxml.lxml` package since lxml
# can handle these security concerns on its own:
# - https://pypi.org/project/defusedxml/#defusedxml-lxml
# - https://github.com/mvantellingen/python-zeep/issues/956

# This package can't fully replace defusedxml, which is still being used by
# libraries other than lxml. https://jira.splunk.com/browse/SPL-103314. These
# libraries are (often) more strict than lxml and will parse XML into
# different/incompatible trees.

# All imports of "from etree" became "from splunk.safe_lxml_etree"

import lxml.etree as etree
from lxml.etree import *
import unittest

# The `import *` doesn't import private "_xyz" specifiers, so add those manually
for k in dir(etree):
    if (k.startswith("_") and not k.startswith("__")):
        globals()[k] = getattr(etree, k)

# SPL-31061, SPL-90436: a previous attempt at ignoring requests for XML external
# entities from 5 years ago. Today, the standard way to do this in lxml has
# changed, but this method is still included just in case. It's not harmful to
# have a null resolver.
class NullResolver(etree.Resolver):
    def resolve(self, url, public_id, context):
        return self.resolve_string('', context)

# https://lxml.de/apidoc/etree.html?highlight=fromstring#etree.XMLParser
safe_parser = etree.XMLParser(resolve_entities=False)
safe_parser.resolvers.add(NullResolver())

# Side-effect of import
etree.set_default_parser(safe_parser)

class XMLException(ValueError):
    def __repr__(self):
        return str(self)

class XMLEntitiesForbidden(XMLException):
    def __init__(self, name, content):
        super(XMLEntitiesForbidden, self).__init__()
        self.name = name
        self.content = content

    def __str__(self):
        tpl = "XMLEntitiesForbidden(name='{}', content={!r})"
        return tpl.format(self.name, self.content)

def validate_tree(elementtree):
    """
    Element trees can have doctype definitions (DTD) but not any entity elements
    """
    docinfo = elementtree.docinfo
    for dtd in docinfo.internalDTD, docinfo.externalDTD:
        if dtd is None:
            continue
        for entity in dtd.iterentities():
            raise XMLEntitiesForbidden(entity.name, entity.content)

# ---

# Override lxml's etree.parse
def parse(source, parser=safe_parser, base_url=None):
    elementtree = etree.parse(source, parser=parser, base_url=base_url)
    validate_tree(elementtree)
    return elementtree

# Override lxml's etree.fromstring
def fromstring(text, parser=safe_parser, base_url=None):
    rootelement = etree.fromstring(text, parser=parser, base_url=base_url)
    elementtree = rootelement.getroottree()
    validate_tree(elementtree)
    return rootelement

# Override lxml's etree.XML
def XML(text, parser=safe_parser, base_url=None):
    rootelement = etree.XML(text, parser=parser, base_url=base_url)
    elementtree = rootelement.getroottree()
    validate_tree(elementtree)
    return rootelement

# Override lxml's etree.XMLParser
class XMLParser(etree.XMLParser):
    def __init__(self, *args, **kwargs):
        kwargs['resolve_entities'] = False
        super(XMLParser, self).__init__(*args, **kwargs)

# ---

class XMLDangerousParsingTest(unittest.TestCase):
    def testFromStringXMLBasic(self):
        et = fromstring("""
            <a>Hello!</a>
        """)
        self.assertEqual(et.text, "Hello!")

    def testUsingEtreeXMLParserClassDirectly(self):
        parser = XMLParser(remove_blank_text=True, remove_comments=True)
        try:
            et = fromstring("""
    <!DOCTYPE foo [
        <!ENTITY OHNO "WOW">
    ]><root></root>""", parser=parser)
        except XMLEntitiesForbidden as e:
            self.assertEqual(e.name, 'OHNO')
            self.assertEqual(e.content, 'WOW')

    def testUsingEtreeXMLParserClassDirectlyBansEnablingEntities(self):
        parser = XMLParser(
            remove_blank_text=True,
            remove_comments=True,
            # This is banned and will be overwritten to =False
            resolve_entities=True,
        )
        try:
            et = fromstring("""
    <!DOCTYPE foo [
        <!ENTITY OHNO "WOW">
    ]><root></root>""", parser=parser)
        except XMLEntitiesForbidden as e:
            self.assertEqual(e.name, 'OHNO')
            self.assertEqual(e.content, 'WOW')

    def testFromStringXMLDoctype(self):
        et = fromstring("""
            <!DOCTYPE foo []>
            <a>Hello!</a>
        """)
        self.assertEqual(et.text, "Hello!")

    # SPL-210612
    def testFromStringXMLEntities(self):
        try:
            et = fromstring("""
    <!DOCTYPE foo [
        <!ENTITY xeebggjd0 "tdifs">
        <!ENTITY xeebggjd1 "&xeebggjd0;&xeebggjd0;">
        <!ENTITY xeebggjd2 "&xeebggjd1;&xeebggjd1;">
        <!ENTITY xeebggjd3 "&xeebggjd2;&xeebggjd2;">
    ]>
    <dashboard version="2" theme="light" hiddenElements="{&quot;hideEdit&quot;:false,&quot;hideOpenInSearch&quot;:false}">
        <label>alifuzzer&xeebggjd3;</label>
        <description>fuzzerrrrrr</description>
        <definition>
            <![CDATA[
                {"visualizations":{"viz_2qVEHSGc":{"type":"viz.img","options":{"preserveAspectRatio":true}},"viz_iqQOXd1E":{"type":"viz222222222222222.img","options":{"preserveAspectRatio":true},"eventHandlers":[{"type":"drilldown.customUrl","options":{"url":"https://www.splunk.com"}}]}},"dataSources":{},"defaults":{"dataSources":{"ds.search":{"options":{"queryParameters":{"latest":"$global_time.latest$","earliest":"$global_time.earliest$"}}}}},"inputs":{"input_global_trp":{"type":"input.timerange","options":{"token":"global_time","defaultValue":"-24h@h,now"},"title":"Global Time Range"}},"layout":{"type":"absolute","options":{"display":"auto-scale"},"structure":[{"item":"viz_2qVEHSGc","type":"block","position":{"x":0,"y":0,"w":150,"h":150}},{"item":"viz_iqQOXd1E","type":"block","position":{"x":20,"y":20,"w":150,"h":150}}],"globalInputs":["input_global_trp"]},"description":"fuzzerrrrrr","title":"alifuzzer"}
            ]]>
        </definition>
        <assets>
            <![CDATA[{}]]>
        </assets>
    </dashboard>
            """)
            raise Exception("Unreachable")
        except XMLEntitiesForbidden as e:
            self.assertEqual(e.name, 'xeebggjd0')
            self.assertEqual(e.content, 'tdifs')

if __name__ == '__main__':
    unittest.main()
