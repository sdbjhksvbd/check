import json
import logging
import os
import shutil
import inspect
import time
from splunk.rest import simpleRequest, format
from splunk.util import normalizeBoolean
from splunk.file_writing_utils import create_parent_dir_if_does_not_exist

def setup_logger():
    sh = logging.StreamHandler()
    sh.setFormatter(logging.Formatter("%(levelname)s %(message)s"))
    logger = logging.getLogger()
    logger.setLevel(logging.WARN)
    logger.addHandler(sh)
    return logger

LOGGER = setup_logger()
QUARANTINED_DIR = os.path.join(os.environ['SPLUNK_HOME'], 'quarantined_files')
MANIFEST_FILE_PATH = os.path.join(QUARANTINED_DIR, 'quarantine_manifest.json')

def load_manifest(manifest_file_path):
    """
    Tries to load the quarantine manifest. Fallback to an empty manifest if load fails.

    @type  manifest_file_path: string
    @param manifest_file_path: The path to the quarantine manifest.

    @rtype: tuple (dict, bool)
    @return: A dictionary representation of the quarantine manifest and a boolean
             representing if the dictionary was loaded from disk successfully.
    """
    manifest = {}
    successfully_loaded_manifest = False
    try:
        with open(manifest_file_path, 'r') as f:
            manifest = json.load(f)
            successfully_loaded_manifest = True
    except Exception as e:
        LOGGER.error('Quarantine files framework - Failed to load quarantine_manifest.json: {}'.format(str(e)))
    return (manifest, successfully_loaded_manifest)

def get_setting_value_dict():
    """
    Gets the mapping of boolean restricted values to readable strings.

    @rtype: dict
    @return: A dictionary containing mapping of keys to readable strings.
    """
    return {
        True: 'restricted',
        False: 'not-restricted',
        'error': 'error',
        'processing': 'processing',
    }

def setting_changed(setting, restrict, manifest_file_path = MANIFEST_FILE_PATH):
    """
    Determines if a setting has been changed or not compared to the last recent execution
    and writes the current setting to the quarantine_manifest to cache.

    @type  setting: string
    @param setting: The name of the setting to store/lookup in the quarantine manifest.

    @type  restrict: bool
    @param restrict: Whether or not the setting should be restricted.

    @type  manifest_file_path: string
    @param manifest_file_path: The path to the quarantine manifest.

    @rtype: bool
    @return: Whether or not the setting has changed.
    """
    setting_value_dict = get_setting_value_dict()
    manifest_exists = os.path.exists(manifest_file_path)
    if manifest_exists:
        (manifest, successfully_loaded_manifest) = load_manifest(manifest_file_path)
        # ignore the cache if loading the manifest failed
        if not successfully_loaded_manifest:
            return True
        setting_in_manifest = setting in manifest
        if setting_in_manifest and (manifest[setting] == 'processing' or manifest[setting] == 'error'):
            LOGGER.warning('Quarantine files framework - Setting: {} - The prior execution of this script ended abruptly. The intended state should be restored by the current run.'.format(setting))
            changed = True
        if setting_in_manifest and (manifest[setting] != setting_value_dict[restrict]):
            changed = True
        elif not setting_in_manifest:
            changed = restrict == True
        else:
            changed = False
    else:
        setting_in_manifest = False
        changed = restrict == True
        manifest = {}
    with open(manifest_file_path, 'w') as f:
        if setting_in_manifest == False:
            manifest[setting] = setting_value_dict[restrict]
        if changed:
            manifest[setting] = 'processing'
        json.dump(manifest, f)
    return changed

def get_base_path(currently_restricted):
    """
    Gets the base path of where files are currently located.

    @type  currently_restricted: bool
    @param currently_restricted: Whether or not files are currently restricted.

    @rtype: string
    @return: The base path of where files are currently located.
    """
    base_path = os.path.join(os.environ['SPLUNK_HOME'])
    return os.path.join(base_path, 'quarantined_files') if currently_restricted else base_path

def generate_destination_paths(original_paths):
    """
    Create the destination paths of where original paths should move to.

    @type  original_paths: list[string]
    @param original_paths: A list of absolute file/directory paths which should be moved.

    @rtype: list[string]
    @return: A list of absolute file/directory paths where original files will be moved to.
    """
    if len(original_paths) <= 0:
        return []
    restricted_path = get_base_path(True)
    original_path = get_base_path(False)
    restricted = original_paths[0].startswith(restricted_path)
    original_base_path = restricted_path if restricted else original_path
    destination_base_path = original_path if restricted else restricted_path
    destination_paths = []
    for path in original_paths:
        relative_path = path.replace(original_base_path, '').replace(os.sep, "", 1)
        destination_path = os.path.join(destination_base_path, relative_path)
        destination_paths.append(destination_path)
    return destination_paths

def move_files(original_paths, destination_paths, restrict, setting = 'unknown'):
    """
    Move files from path A to B.

    @type  original_paths: list[string]
    @param original_paths: A list of absolute file/directory paths which should be moved.

    @type  destination_paths: list[string]
    @param destination_paths: A list of absolute file/directory paths where original files will be moved to.

    @type  restrict: bool
    @param restrict: Whether or not the setting should be restricted.

    @type  setting: string
    @param setting: The name of the setting to store/lookup in the quarantine manifest.

    @rtype: bool
    @return: Whether or not files have been moved correctly
    """
    successfully_moved_files = True
    for i in range(len(original_paths)):
        original_path = original_paths[i]
        destination_path = destination_paths[i]
        create_parent_dir_if_does_not_exist(destination_path)
        original_path_exists = os.path.exists(original_path)
        destination_path_exists = os.path.exists(destination_path)
        try:
            if original_path_exists:
                if destination_path_exists:
                    LOGGER.warning('Quarantine files framework - Setting {} - Anomaly moving files: destination path {} already exists.'.format(setting, original_path))
                    if restrict:
                        # restricting, quarantine the updated file
                        shutil.rmtree(destination_path) if os.path.isdir(destination_path) else os.remove(destination_path)
                        os.rename(original_path, destination_path)
                    else:
                        # restoring, delete the old quarantined file
                        shutil.rmtree(original_path) if os.path.isdir(original_path) else os.remove(original_path)
                else:
                    os.rename(original_path, destination_path)
            elif not destination_path_exists:
                successfully_moved_files = False
                LOGGER.error('Quarantine files framework - Setting {} - Anomaly moving files: Original path {} does not exist. This could be due to restricted permissions for this path.'.format(setting, original_paths[i]))
        except Exception as e:
            LOGGER.error('Quarantine files framework - Setting {} - Unexpected error when moving path "{}": {}'.format(setting, original_paths[i], str(e)))
    return successfully_moved_files

def clean_quarantined_directory(quarantined_dir = QUARANTINED_DIR):
    """
    Delete any empty directories after moving files out of the quarantined directory

    @type  quarantined_dir: string
    @param quarantined_dir: A path to the quarantined directory

    @rtype: None
    """
    for path, directories, files in os.walk(quarantined_dir, topdown=False):
        for directory in directories:
            candidate_dir = os.path.realpath(os.path.join(path, directory))
            if len(os.listdir(candidate_dir)) == 0:
                os.rmdir(candidate_dir)
    if len(os.listdir(quarantined_dir)) == 0:
        os.rmdir(quarantined_dir)

def update_manifest(setting, restrict, manifest_file_path = MANIFEST_FILE_PATH):
    """
    Updates the manifest to denote that a process that is running is now completed
    with the given restriction value.

    @type  setting: string
    @param setting: The name of the setting to store/lookup in the quarantine manifest.

    @type  restrict: bool
    @param restrict: Whether or not the setting should be restricted.

    @type  manifest_file_path: string
    @param manifest_file_path: The path to the quarantine manifest.

    @rtype: None
    """
    setting_value_dict = get_setting_value_dict()
    (manifest, successfully_loaded_manifest) = load_manifest(manifest_file_path)
    with open(manifest_file_path, 'w') as f:
        manifest[setting] = setting_value_dict[restrict]
        json.dump(manifest, f)

def update_restriction(config, web_settings):
    disallow_renabling_insecure_libraries = normalizeBoolean(web_settings["allow_insecure_libraries_toggle"]) == False
    if config.restricted_files_are_insecure and disallow_renabling_insecure_libraries:
        config.should_restrict = True

def log_toggle_information(config, start_time):
    flag_toggle = 'Disabled' if config.should_restrict else 'Enabled'
    script_duration = float("{0:.3f}".format(time.time() - start_time)) # format to 3 decimals
    LOGGER.warning('Quarantine files framework - {} Toggle {}. Script duration {}s'.format(config.setting, flag_toggle, script_duration))

def bump_ui_version():
    push_version_path = os.path.join(os.environ['SPLUNK_HOME'], 'var', 'run', 'splunk', 'push-version.txt')
    push_version_exists = os.path.exists(push_version_path)
    old_push_version = 0
    if push_version_exists:
        with open(push_version_path, 'r') as f:
            old_push_version = int(f.read(20))
    with open(push_version_path, 'w') as f:
        f.write(str(old_push_version + 1))

def get_web_settings(session_key):
    (response, data) = simpleRequest(
        path='/servicesNS/nobody/system/configs/conf-web/settings',
        sessionKey=session_key,
        raiseAllErrors=True
    )
    if response.status == 200:
        parsed_data = format.parseFeedDocument(data)
        return parsed_data.toPrimitive()["settings"]
    else:
        raise Exception('Failed to get web settings with status code {}'.format(response.status))
