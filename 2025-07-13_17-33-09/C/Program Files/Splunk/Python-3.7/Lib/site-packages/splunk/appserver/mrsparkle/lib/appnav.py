from __future__ import absolute_import
from builtins import object

import logging

from future.moves.urllib import parse as urllib_parse

import splunk.safe_lxml_etree as et
import lxml.html
import cherrypy

import splunk.entity as en
import splunk.util
import splunk.appserver.mrsparkle
import splunk.appserver.mrsparkle.lib.config as config
import splunk.appserver.mrsparkle.lib.util as util

logger = logging.getLogger('splunk.appserver.lib.appnav')

# define path to get current app view organization data
NAV_ENTITY_CLASS = 'data/ui/nav'
NAV_ENTITY_NAME = 'default'
NAV_ALT_ENTITY_NAME_S = 'default-%s'
NAV_CLASS_FREE = 'free'

DEFAULT_DISPLAYVIEW = 'flashtimeline'
LINK_NODE_URI_SCHEME_WHITELIST = ['http', 'https', 'mailto', '']

def getAppNav(app, viewManifest=None, searches=None, use_app_bar_performance_optimizations=False):
    '''
    A utility function that uses the AppNav object and returns
    a tuple with the nav tree and the default view. This is the same ouput
    as the old view.py getAppNav function
    '''
    if use_app_bar_performance_optimizations:
        appNavObj = AppNav(app, searches=searches, use_app_bar_performance_optimizations=use_app_bar_performance_optimizations)
    else: 
        visibleViews = {} #viewManifest #[view for view in viewManifest if viewManifest[view].get('isVisible')]
        for view in viewManifest:
            if viewManifest[view].get('isVisible'):
                visibleViews[view] = viewManifest[view]
        appNavObj = AppNav(app, viewManifest=visibleViews, searches=searches, use_app_bar_performance_optimizations=use_app_bar_performance_optimizations)
    nav = appNavObj.getNav()
    defaultView = appNavObj.getDefaultView()
    color = appNavObj.getNavColor()
    return (nav, defaultView, color)

class AppNav(object):
    '''
    Instantiate an AppNav object in order to parse information from nav XML
    and build a fleshed out navigation hierarchy
    '''

    # inputs
    app = None
    viewManifest = None
    searches = None

    # data from splunkd entity
    _navDefinitionXML = None

    # outputs
    _nav = None
    _defaultView = None
    _navColor = None

    # feature flag
    use_app_bar_performance_optimizations = False

    def __init__(self, app, viewManifest=None, searches=None, navData=None, use_app_bar_performance_optimizations=False):
        self.use_app_bar_performance_optimizations = use_app_bar_performance_optimizations
        self.app = app

        if (not self.use_app_bar_performance_optimizations) and viewManifest != None:
            self.viewManifest = viewManifest
        if searches != None:
            self.searches = searches
        if navData != None:
            self._navDefinitionXML = self._parseNavDefinitionXML(navData)

    def getNav(self):
        if self._nav != None:
            return self._nav

        self._buildNav()
        return self._nav

    def getDefaultView(self):
        if self._defaultView != None:
            return self._defaultView

        self._buildNav()
        return self._defaultView

    def getNavColor(self):
        if self._navColor != None:
            return self._navColor

        navDefinitionXML = self._getNavDefinitionXML()
        if navDefinitionXML is not None:
            # check for specification of navColor in the root node
            self._navColor = navDefinitionXML.get('color')
            return self._navColor
        else:
            return None

    def _getFirstView(self):
        first_view = en.getEntity('data/ui/views', namespace=self.app, count=1, digest=1, search='isVisible=1')
        return first_view

    def _getViewManifest(self):
        if (not self.use_app_bar_performance_optimizations) and self.viewManifest != None:
            return self.viewManifest
        viewManifest = {}
        try:
            views = en.getEntities('data/ui/views', namespace=self.app, count=-1, digest=1, search='isVisible=1')
            for view in views:
                viewManifest[view]= {
                    'label':views.get(view, {}).get('label', view),
                    'isVisible':views.get(view, {}).get('isVisible', 1),
                    'isDashboard':views.get(view, {}).get('isDashboard', 1),
                    'name':view,
                    'app':views.get(view, {}).get('eai:acl', {}).get('app', "")
                    }
        except splunk.ResourceNotFound:
            logger.warn('Unable to retrieve current views')
        
        if not self.use_app_bar_performance_optimizations:
            self.viewManifest = viewManifest

        return viewManifest

    def _getSearches(self):
        if self.searches != None:
            return self.searches

        try:
            # Customers with 3k+ savedsearches run into high cpu and memory usage
            # Maximum count is recommended to be at 500.
            fetchCount = config.getConfig(sessionKey=cherrypy.session.get('sessionKey'), namespace=None).get('APP_NAV_REPORTS_LIMIT') or 500
            self.searches = en.getEntities('saved/searches', namespace=self.app, search='is_visible=1 AND disabled=0', count=fetchCount, _with_new='1')
            if '_new' in self.searches:
                del self.searches['_new']
        except splunk.ResourceNotFound:
            logger.warn('Unable to retrieve current saved searches')
            self.searches = {}
        return self.searches

    def _getNavDefinitionXML(self):
        if self._navDefinitionXML is not None:
            return self._navDefinitionXML

        navDefinition = None
        navAltClass = None

        # set alternate class
        if cherrypy.config.get('is_free_license'):
            navAltClass = NAV_CLASS_FREE

        # try alternate nav
        if navAltClass:
            try:
                navDefinition = en.getEntity(NAV_ENTITY_CLASS, NAV_ALT_ENTITY_NAME_S % NAV_CLASS_FREE, namespace=self.app)
            except splunk.ResourceNotFound:
                pass

        # if no alt, then proceed with default
        if not navDefinition:
            try:
                navDefinition = en.getEntity(NAV_ENTITY_CLASS, NAV_ENTITY_NAME, namespace=self.app)
            except splunk.ResourceNotFound:
                logger.warn('"%s" app does not have a navigation configuration file defined.' % self.app) # TK mgn 06/19/09
            except Exception as e:
                logger.exception(e)
                raise

        # parse the XML
        self._navDefinitionXML = self._parseNavDefinitionXML(navDefinition)

        return self._navDefinitionXML

    def _parseNavDefinitionXML(self, navDefinition):
        navDefinitionXML = None
        try:
            parser = et.XMLParser(remove_blank_text=True)
            navDefinitionXML = et.fromstring(navDefinition['eai:data'], parser=parser)
        except et.XMLSyntaxError as e:
            logger.error('Invalid app nav XML encountered: %s' % e)
        except Exception as e:
            logger.error('Unable to parse nav XML for app=%s; %s' % (self.app, e))
        return navDefinitionXML

    def _buildNav(self):
        if not self.use_app_bar_performance_optimizations:
            viewManifest = self._getViewManifest()
        navDefinitionXML = self._getNavDefinitionXML()
        output = []

        # if application has nav defined
        if navDefinitionXML is not None:

            # empty nav means don't do anything; omitted nav is treated down below
            if len(navDefinitionXML) == 0:
                return output

            if self.use_app_bar_performance_optimizations:
                self._replaceNavTokens(navDefinitionXML)
                output = self._decorateNavItems(navDefinitionXML, app=self.app)
            else:
                self._replaceNavTokens(navDefinitionXML, viewManifest)
                output = self._decorateNavItems(navDefinitionXML, viewManifest, self.app)

            # check for the default view; if no default set, pick the first
            # view listed in nav; if none, try to get first in manifest
            defaultNodes = navDefinitionXML.xpath('//view[@default]')
            for node in defaultNodes:
                if splunk.util.normalizeBoolean(node.get('default')):
                    defaultView = node.get('name')
                    break
            else:
                fallbackNodes = navDefinitionXML.xpath('//view[@name]')
                for node in fallbackNodes:
                    defaultView = node.get('name')
                    break
                else:
                    if self.use_app_bar_performance_optimizations:
                        first_view = self._getFirstView()
                        defaultView = first_view.keys()[0]
                    else:
                        defaultView = sorted(viewManifest.keys())[0]


        # otherwise dump all views into a generic menu
        else:
            logger.warn('Unable to process navigation configuration for app "%s"; using defaults.' % self.app) # TK mgn 06/19/09
            DEFAULT_VIEW_COLLECTION = 'Default Views'
            viewManifest = self._getViewManifest()
            output.append({
                'label': DEFAULT_VIEW_COLLECTION,
                'submenu': [
                    {'label': _(viewManifest[name]['label']), 'uri': name}
                    for name
                    in sorted(viewManifest)
                ]
            })

            defaultView = DEFAULT_DISPLAYVIEW

        self._nav = output
        self._defaultView = defaultView

    def _replaceNavTokens(self, navDefinitionXML, viewManifest=None):
        '''
        Inserts the proper view and saved search items as required by the XML
        nodes placed into the nav XML data.  Modified the 'navDefinitionXML' lxml
        node in-place.

        The XML nodes currently recognized are:
            <view source="unclassified" />
            <view source="all" />
        '''

        # get a list of explicitly marked views and saved searches
        searches = None
        markedViews = []
        for node in navDefinitionXML.xpath('//view[@name]'):
            markedViews.append(node.get('name'))

        markedSaved = []
        if self.use_app_bar_performance_optimizations:
            source_nodes = navDefinitionXML.xpath('//view[@source]')
            viewManifest = {}
        else:
            source_nodes = navDefinitionXML.xpath('//saved[@name]')

        for node in source_nodes:
            if searches is None:
                searches = self._getSearches()

            if node.get('name') in searches:
                savedSearch = searches[node.get('name')]
                node.set('uri', savedSearch.getLink('alternate'))
                node.set('sharing', savedSearch.get('eai:acl', {}).get('sharing'))
                markedSaved.append(node.get('name'))
            else:
                node.getparent().remove(node)
        #
        # handle views
        # identify the <view source="" /> nodes and fill in with views
        #
        for node in navDefinitionXML.xpath('//view[@source]'):
            source = node.get('source')
            match  = node.get('match', '').lower()

            if source == 'all':
                for viewName in sorted(viewManifest):
                    if match and viewName.lower().find(match) == -1:
                        continue
                    if not splunk.util.normalizeBoolean(viewManifest.get(viewName, {}).get('isDashboard')):
                        continue
                    linkNode = et.Element('view')
                    linkNode.set('name', viewName)
                    node.addprevious(linkNode)

            elif source == 'unclassified':
                for viewName in sorted(viewManifest):
                    if (viewName in markedViews) or (match and viewName.lower().find(match) == -1):
                        continue
                    if not splunk.util.normalizeBoolean(viewManifest.get(viewName, {}).get('isDashboard')):
                        continue

                    linkNode = et.Element('view')
                    linkNode.set('name', viewName)
                    node.addprevious(linkNode)
                    if match:
                        markedViews.append(viewName)
            else:
                logger.warn('Unable to process view item; unknown source: %s' %  source)

            node.getparent().remove(node)

        #
        # handle saved searches
        # identify the <saved source="" /> nodes and fill in with the proper
        # saved search items; allow matching on name substring
        #
        for node in navDefinitionXML.xpath('//saved[@source]'):
            if searches is None:
                searches = self._getSearches()

            source = node.get('source', '').lower()
            match = node.get('match', '').lower()

            if source == 'all':
                keys = splunk.util.objUnicode(list(searches.keys()))
                for savedName in sorted(keys, key=splunk.util.unicode.lower):
                    if match and savedName.lower().find(match) == -1:
                        continue
                    savedNode = et.Element('saved')
                    savedNode.set('name', savedName)
                    savedNode.set('uri', searches[savedName].getLink("alternate"))
                    savedNode.set('sharing', searches[savedName].get('eai:acl', {}).get('sharing'))
                    dispatch_view = searches[savedName].get('request.ui_dispatch_view')
                    if dispatch_view:
                        savedNode.set('dispatchView', dispatch_view)
                    if node.get('view'):
                        savedNode.set('view', node.get('view'))
                    node.addprevious(savedNode)

            elif source == 'unclassified':
                keys = splunk.util.objUnicode(list(searches.keys()))
                for savedName in sorted(keys, key=splunk.util.unicode.lower):
                    if savedName not in markedSaved:
                        if match and savedName.lower().find(match) == -1:
                            continue
                        savedNode = et.Element('saved')
                        savedNode.set('name', savedName)
                        savedNode.set('uri', searches[savedName].getLink("alternate"))
                        savedNode.set('sharing', searches[savedName].get('eai:acl', {}).get('sharing'))
                        dispatch_view = searches[savedName].get('request.ui_dispatch_view')
                        if dispatch_view:
                            savedNode.set('dispatchView', dispatch_view)
                        if node.get('view'):
                            savedNode.set('view', node.get('view'))
                        node.addprevious(savedNode)
                        if match:
                            markedSaved.append(savedName)

            else:
                logger.warn('Unable to process saved search item; unknown source: %s' % source)

            node.getparent().remove(node)

    def _decorateNavItems(self, branch, viewManifest=None, app=None):
        '''
        Rewrites the incoming nav definition by decorating view names with
        proper links, and saved searches as views with search name specified.
        This recursive method is used by getAppNav().

        Input Example:
            <nav>
                <collection label="Dashboards">
                    <a href="http://google.com">Google</a>
                </collection>
                <collection label="Views">
                    <view source="all" />
                </collection>
                <collection label="Saved Searches" sort="alpha">
                    <collection label="Recent Searches">
                        <saved source="recent" />
                    </collection>
                    <saved name="All firewall errors" />
                    <divider />
                </collection>
            </nav>

        Output Example:


        '''

        output = []
        for node in branch:
            # update the view nodes with the proper links and labels
            if node.tag == 'view':
                if self.use_app_bar_performance_optimizations:
                    output.append({
                        'viewName': node.get('name'),
                        'label': _(node.get('label')),
                        'uri': util.make_url(['app', app, node.get('name', '')])
                    })
                else:
                    viewData = viewManifest.get(node.get('name'))
                    if viewData:
                        if viewData['isVisible']:
                            output.append({
                                'viewName': node.get('name'),
                                'label': _(viewData.get('label')),
                                'uri': util.make_url(['app', app, node.get('name', '')])
                            })
                    else:
                        logger.warn(_('An unknown view name \"%(view)s\" is referenced in the navigation definition for \"%(app)s\".') % {'view': node.get('name'), 'app': app})
            # update saved searches and point them to the saved search redirector
            elif node.tag == 'saved':
                if node.get('view'):
                    uri = util.make_url(
                        ['app', app, node.get('view')],
                        {'s': node.get('uri')}
                    )
                else:
                    uri = util.make_url(
                        ['app', app, '@go'],
                        {'s': node.get('uri')}
                    )
                reportUri = util.make_url(
                        ['app', app, 'report'],
                        {'s': node.get('uri')}
                    )
                searchDict = {
                    'label': node.get('name'),
                    'uri': uri,
                    'reportUri': reportUri,
                    'sharing': node.get('sharing', None)
                    }
                if node.get('dispatchView'):
                    searchDict['dispatchView'] = node.get('dispatchView')
                output.append(searchDict)

            elif node.tag == 'a':
                uri = node.get('href')

                if uri.startswith('/'):
                    uri = util.make_url(uri)

                (isAllowed, uriScheme) = self._isAllowedUriScheme(uri)
                if not isAllowed:
                    logger.warning("Prohibited scheme specified for link node in nav definition. app='%s' label='%s'. scheme='%s' not in whitelist=%s" % (app, node.text, uriScheme, LINK_NODE_URI_SCHEME_WHITELIST))
                    continue

                anchor = {
                    'label': _(node.text),
                    'uri': uri
                }
                if node.get('target') == '_blank':
                    anchor['external'] = True
                output.append(anchor)

            elif node.tag == 'divider':
                output.append({
                    'label': '------',
                    'uri': '#',
                    'divider': 'actionsMenuDivider'
                })

            elif node.tag == 'collection':
                # can remove viewManifest parameter for _decorateNavItems once we remove the feature flag
                if self.use_app_bar_performance_optimizations:
                    viewManifestSubmenu = None
                else:
                    viewManifestSubmenu = viewManifest
                subcollection = {
                    'label': _(node.get('label')),
                    'submenu': self._decorateNavItems(node, viewManifest=viewManifestSubmenu, app=app)
                }

                # only show submenu if it contains something
                if len(subcollection['submenu']) > 0:
                    output.append(subcollection)

        if self.isEmpty(output):
            return []

        return output

    def isEmpty(self, nav):
        for el in nav:
            if not 'divider' in el:
                return False
        return True

    def _isAllowedUriScheme(self, uri):
        # pylint: disable=E1101
        uri = uri.strip()

        # we allow empty uri
        if uri is None or len(uri) == 0:
            return (True, "")

        # need to remove all whitespace from uri, even if html-encoded
        uri = lxml.html.fromstring(uri).text

        # we are not preventing an HTML element without inner text
        if uri is None or len(uri) == 0:
            return (True, "")

        uri = "".join(uri.split())

        # whitelist uri scheme to make sure no malicious hrefs make their way in
        uriParts = urllib_parse.urlparse(uri)
        if not uriParts.scheme.lower() in LINK_NODE_URI_SCHEME_WHITELIST:
            return (False, uriParts.scheme)

        return (True, uriParts.scheme)

# Tests
"""
Iterate TDD with `echo py/3/splunk/appserver/mrsparkle/lib/appnav.py | entr splunk cmd python /_`
which will re-run the whole test suite on file save.

Debug with VSCode launch.json using `"python": "/usr/local/bin/vscode-python.sh",` which is:
```
#!/bin/bash
splunk cmd python $@
```
"""
import unittest

class AppNavXmlTest(unittest.TestCase):

    def setUp(self):
        # Failing CI pipelines? Says `TypeError: 'bool' object is not callable`
        global _
        try:
            _()
        except Exception:
            def _(message):
                return message
        cherrypy.request.lang = "en-US"
        cherrypy.request.config = {'root_endpoint': '/'}

    def testBasic(self):
        nav_xml = """
            <nav search_view="search" color="#5CC05C">
                <view name="search" default="true" />
                <view name="analytics_workspace" />
                <view name="datasets" />
                <view name="reports" />
                <view name="alerts" />
                <view name="dashboards" />
            </nav>
        """
        appnav = AppNav("search",
            navData={ "eai:data": nav_xml },
            viewManifest={
                "search": {
                    "isVisible": 1,
                    "isDashboard": 0,
                    "label": "Search",
                    "name": "search",
                    "app": "search",
                },
                "analytics_workspace": {
                    "isVisible": 1,
                    "isDashboard": 0,
                    "label": "Analytics Workspace",
                    "name": "analytics_workspace",
                    "app": "search",
                },
                "datasets": {
                    "isVisible": 1,
                    "isDashboard": 0,
                    "label": "Datasets",
                    "name": "datasets",
                    "app": "search",
                },
                "reports": {
                    "isVisible": 1,
                    "isDashboard": 0,
                    "label": "Reports",
                    "name": "reports",
                    "app": "search",
                },
                "alerts": {
                    "isVisible": 1,
                    "isDashboard": 0,
                    "label": "Alerts",
                    "name": "alerts",
                    "app": "search",
                },
                "dashboards": {
                    "isVisible": 1,
                    "isDashboard": 0,
                    "label": "Dashboards",
                    "name": "dashboards",
                    "app": "search",
                }
        })
        self.assertEqual(
            appnav.getNav(),
            [
                {'viewName': 'search', 'label': 'Search', 'uri': '/en-US/app/search/search'},
                {'viewName': 'analytics_workspace', 'label': 'Analytics Workspace', 'uri': '/en-US/app/search/analytics_workspace'},
                {'viewName': 'datasets', 'label': 'Datasets', 'uri': '/en-US/app/search/datasets'},
                {'viewName': 'reports', 'label': 'Reports', 'uri': '/en-US/app/search/reports'},
                {'viewName': 'alerts', 'label': 'Alerts', 'uri': '/en-US/app/search/alerts'},
                {'viewName': 'dashboards', 'label': 'Dashboards', 'uri': '/en-US/app/search/dashboards'}
            ]
        )

    def testSpl231190(self):
        nav_xml = """
            <nav search_view="search" color="#5CC05C">
                <view name="search" default="true" />
                <collection label="dc">
                    <collection label="dc>net">
                        <saved source="unclassified" match="dc>net"/>
                        <view source="unclassified" match="__dc_net"/>
                    </collection>
                </collection>
            </nav>
        """
        savedsearches = en.EntityCollection()
        for x in ['whoa1', 'whoa2', 'savedsearch_dc>net']:
            savedsearches[x] = en.Entity('saved/searches', x, {
                "app": "search", "id": "/servicesNS/nobody/search/saved/searches/xyz", "search": "*", "eai:acl": { "sharing": "app" }
            })
            savedsearches[x].links = [("alternate", "???")]
        appnav = AppNav("search",
            navData={ "eai:data": nav_xml },
            viewManifest={
                "search": {
                    "isVisible": 1,
                    "isDashboard": 0,
                    "label": "Search",
                    "name": "search",
                    "app": "search",
                },
                "sxml_dashboard": {
                    "isVisible": 1,
                    "isDashboard": 1,
                    "label": "SXML Dashboard",
                    "name": "sxml_dashboard",
                    "app": "search",
                    "viewEntry": {
                        "rootNode": "dashboard",
                        "version": "1.1",
                    }
                },
                "studio_dashboard__dc_net_": {
                    "isVisible": 1,
                    "isDashboard": 1,
                    "label": "Studio Dashboard (dc>net)",
                    "name": "studio_dashboard__dc_net_",
                    "app": "search",
                    "viewEntry": {
                        "rootNode": "dashboard",
                        "version": "2",
                    },
                }
            },
            searches=savedsearches
        )
        self.maxDiff = None
        self.assertEqual(
            appnav.getNav(),
            [
                {
                    'label': 'Search',
                    'uri': '/en-US/app/search/search',
                    'viewName': 'search',
                },
                {
                    'label': 'dc',
                    'submenu': [
                        {
                            'label': 'dc>net',
                            'submenu': [
                                {
                                    'label': 'savedsearch_dc>net',
                                    'reportUri': '/en-US/app/search/report?s=%3F%3F%3F',
                                    'sharing': 'app',
                                    'uri': '/en-US/app/search/%40go?s=%3F%3F%3F'
                                },
                                {
                                    'label': 'Studio Dashboard (dc>net)',
                                    'uri': '/en-US/app/search/studio_dashboard__dc_net_',
                                    'viewName': 'studio_dashboard__dc_net_'
                                },
                            ]
                        }
                    ]
                }
            ]
        )


class UriSchemeProhibitionTest(unittest.TestCase):

    def testAllowed(self):
        allowedUris = [ "http://google.com",
                        "https://google.com",
                        "otherview",
                        "/app/otherapp/otherview",
                        "/manager/otherapp/otherview",
                        "mailto:arobbins@splunk.com",
                        " ",
                        "<a>",
                        "&lt;a&gt;" ]

        appnav = AppNav("test")
        for uri in allowedUris:
            (allowed, scheme) = appnav._isAllowedUriScheme(uri)
            self.assertEqual(allowed, True)

    def testProhibited(self):
        prohibitedUris = [  "javascript:alert('HACKED!');",
                            "    javascript:alert('HACKED!');",
                            "javascript:alert('HACKED!');  ",
                            "java&#09;script&#09;:alert('HACKED!');",
                            "java&#13;script&#13;:alert('HACKED!');" ]

        appnav = AppNav("test")
        for uri in prohibitedUris:
            (allowed, scheme) = appnav._isAllowedUriScheme(uri)
            self.assertEqual(allowed, False)


if __name__ == '__main__':
    unittest.main()
