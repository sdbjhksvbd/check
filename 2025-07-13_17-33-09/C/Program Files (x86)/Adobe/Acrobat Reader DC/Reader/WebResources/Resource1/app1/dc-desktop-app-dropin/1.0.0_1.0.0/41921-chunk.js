(self["webpackJsonp-desktop-app"]=self["webpackJsonp-desktop-app"]||[]).push([[41921],{vyzc:(e,t,n)=>{"use strict";n.d(t,{A:()=>NativeWebviewUtils});class NativeWebviewUtils{}NativeWebviewUtils.IsRunningInNativeWebView=()=>window.gIsNativeWebview,NativeWebviewUtils.GetActualObjectFromProxyObject=e=>{const t=window.gProxyRealValPropName;return e[t]?e[t]:e},NativeWebviewUtils.PostMessageToNativeWindows=(e,t)=>{var n;null===(n=window.chrome)||void 0===n||n.webview.postMessageWithAdditionalObjects(e,t)}},Cqqu:(e,t,n)=>{"use strict";function ownKeys(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(n),!0).forEach((function(t){_defineProperty(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ownKeys(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function _defineProperty(e,t,n){return(t=function _toPropertyKey(e){var t=function _toPrimitive(e,t){if("object"!=typeof e||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,t||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:t+""}(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function isArray(e){return Array.isArray?Array.isArray(e):"[object Array]"===getTag(e)}n.d(t,{A:()=>Fuse});function isString(e){return"string"==typeof e}function isNumber(e){return"number"==typeof e}function isBoolean(e){return!0===e||!1===e||function isObjectLike(e){return isObject(e)&&null!==e}(e)&&"[object Boolean]"==getTag(e)}function isObject(e){return"object"==typeof e}function isDefined(e){return null!=e}function isBlank(e){return!e.trim().length}function getTag(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const r=Object.prototype.hasOwnProperty;class KeyStore{constructor(e){this._keys=[],this._keyMap={};let t=0;e.forEach((e=>{let n=createKey(e);t+=n.weight,this._keys.push(n),this._keyMap[n.id]=n,t+=n.weight})),this._keys.forEach((e=>{e.weight/=t}))}get(e){return this._keyMap[e]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}function createKey(e){let t=null,n=null,i=null,s=1,c=null;if(isString(e)||isArray(e))i=e,t=createKeyPath(e),n=createKeyId(e);else{if(!r.call(e,"name"))throw new Error((e=>`Missing ${e} property in key`)("name"));const o=e.name;if(i=o,r.call(e,"weight")&&(s=e.weight,s<=0))throw new Error((e=>`Property 'weight' in key '${e}' must be a positive integer`)(o));t=createKeyPath(o),n=createKeyId(o),c=e.getFn}return{path:t,id:n,weight:s,src:i,getFn:c}}function createKeyPath(e){return isArray(e)?e:e.split(".")}function createKeyId(e){return isArray(e)?e.join("."):e}const i={useExtendedSearch:!1,getFn:function get(e,t){let n=[],r=!1;const deepGet=(e,t,i)=>{if(isDefined(e))if(t[i]){const s=e[t[i]];if(!isDefined(s))return;if(i===t.length-1&&(isString(s)||isNumber(s)||isBoolean(s)))n.push(function toString(e){return null==e?"":function baseToString(e){if("string"==typeof e)return e;let t=e+"";return"0"==t&&1/e==-1/0?"-0":t}(e)}(s));else if(isArray(s)){r=!0;for(let e=0,n=s.length;e<n;e+=1)deepGet(s[e],t,i+1)}else t.length&&deepGet(s,t,i+1)}else n.push(e)};return deepGet(e,isString(t)?t.split("."):t,0),r?n:n[0]},ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1};var s=_objectSpread(_objectSpread(_objectSpread(_objectSpread({},{isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1}),{includeMatches:!1,findAllMatches:!1,minMatchCharLength:1}),{location:0,threshold:.6,distance:100}),i);const c=/[^ ]+/g;class FuseIndex{constructor(){let{getFn:e=s.getFn,fieldNormWeight:t=s.fieldNormWeight}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.norm=function norm(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Map,r=Math.pow(10,t);return{get(t){const i=t.match(c).length;if(n.has(i))return n.get(i);const s=1/Math.pow(i,.5*e),o=parseFloat(Math.round(s*r)/r);return n.set(i,o),o},clear(){n.clear()}}}(t,3),this.getFn=e,this.isCreated=!1,this.setIndexRecords()}setSources(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.docs=e}setIndexRecords(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.records=e}setKeys(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.keys=e,this._keysMap={},e.forEach(((e,t)=>{this._keysMap[e.id]=t}))}create(){!this.isCreated&&this.docs.length&&(this.isCreated=!0,isString(this.docs[0])?this.docs.forEach(((e,t)=>{this._addString(e,t)})):this.docs.forEach(((e,t)=>{this._addObject(e,t)})),this.norm.clear())}add(e){const t=this.size();isString(e)?this._addString(e,t):this._addObject(e,t)}removeAt(e){this.records.splice(e,1);for(let t=e,n=this.size();t<n;t+=1)this.records[t].i-=1}getValueForItemAtKeyId(e,t){return e[this._keysMap[t]]}size(){return this.records.length}_addString(e,t){if(!isDefined(e)||isBlank(e))return;let n={v:e,i:t,n:this.norm.get(e)};this.records.push(n)}_addObject(e,t){let n={i:t,$:{}};this.keys.forEach(((t,r)=>{let i=t.getFn?t.getFn(e):this.getFn(e,t.path);if(isDefined(i))if(isArray(i)){let e=[];const t=[{nestedArrIndex:-1,value:i}];for(;t.length;){const{nestedArrIndex:n,value:r}=t.pop();if(isDefined(r))if(isString(r)&&!isBlank(r)){let t={v:r,i:n,n:this.norm.get(r)};e.push(t)}else isArray(r)&&r.forEach(((e,n)=>{t.push({nestedArrIndex:n,value:e})}))}n.$[r]=e}else if(isString(i)&&!isBlank(i)){let e={v:i,n:this.norm.get(i)};n.$[r]=e}})),this.records.push(n)}toJSON(){return{keys:this.keys,records:this.records}}}function createIndex(e,t){let{getFn:n=s.getFn,fieldNormWeight:r=s.fieldNormWeight}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=new FuseIndex({getFn:n,fieldNormWeight:r});return i.setKeys(e.map(createKey)),i.setSources(t),i.create(),i}function computeScore$1(e){let{errors:t=0,currentLocation:n=0,expectedLocation:r=0,distance:i=s.distance,ignoreLocation:c=s.ignoreLocation}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const o=t/e.length;if(c)return o;const a=Math.abs(r-n);return i?o+a/i:a?1:o}const o=32;function search(e,t,n){let{location:r=s.location,distance:i=s.distance,threshold:c=s.threshold,findAllMatches:a=s.findAllMatches,minMatchCharLength:h=s.minMatchCharLength,includeMatches:l=s.includeMatches,ignoreLocation:u=s.ignoreLocation}=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(t.length>o)throw new Error(`Pattern length exceeds max of ${o}.`);const d=t.length,g=e.length,f=Math.max(0,Math.min(r,g));let p=c,y=f;const m=h>1||l,M=m?Array(g):[];let x;for(;(x=e.indexOf(t,y))>-1;){let e=computeScore$1(t,{currentLocation:x,expectedLocation:f,distance:i,ignoreLocation:u});if(p=Math.min(e,p),y=x+d,m){let e=0;for(;e<d;)M[x+e]=1,e+=1}}y=-1;let v=[],S=1,b=d+g;const w=1<<d-1;for(let r=0;r<d;r+=1){let s=0,c=b;for(;s<c;){computeScore$1(t,{errors:r,currentLocation:f+c,expectedLocation:f,distance:i,ignoreLocation:u})<=p?s=c:b=c,c=Math.floor((b-s)/2+s)}b=c;let o=Math.max(1,f-c+1),h=a?g:Math.min(f+c,g)+d,l=Array(h+2);l[h+1]=(1<<r)-1;for(let s=h;s>=o;s-=1){let c=s-1,a=n[e.charAt(c)];if(m&&(M[c]=+!!a),l[s]=(l[s+1]<<1|1)&a,r&&(l[s]|=(v[s+1]|v[s])<<1|1|v[s+1]),l[s]&w&&(S=computeScore$1(t,{errors:r,currentLocation:c,expectedLocation:f,distance:i,ignoreLocation:u}),S<=p)){if(p=S,y=c,y<=f)break;o=Math.max(1,2*f-y)}}if(computeScore$1(t,{errors:r+1,currentLocation:f,expectedLocation:f,distance:i,ignoreLocation:u})>p)break;v=l}const k={isMatch:y>=0,score:Math.max(.001,S)};if(m){const e=function convertMaskToIndices(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:s.minMatchCharLength,n=[],r=-1,i=-1,c=0;for(let s=e.length;c<s;c+=1){let s=e[c];s&&-1===r?r=c:s||-1===r||(i=c-1,i-r+1>=t&&n.push([r,i]),r=-1)}return e[c-1]&&c-r>=t&&n.push([r,c-1]),n}(M,h);e.length?l&&(k.indices=e):k.isMatch=!1}return k}function createPatternAlphabet(e){let t={};for(let n=0,r=e.length;n<r;n+=1){const i=e.charAt(n);t[i]=(t[i]||0)|1<<r-n-1}return t}class BitapSearch{constructor(e){let{location:t=s.location,threshold:n=s.threshold,distance:r=s.distance,includeMatches:i=s.includeMatches,findAllMatches:c=s.findAllMatches,minMatchCharLength:a=s.minMatchCharLength,isCaseSensitive:h=s.isCaseSensitive,ignoreLocation:l=s.ignoreLocation}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this.options={location:t,threshold:n,distance:r,includeMatches:i,findAllMatches:c,minMatchCharLength:a,isCaseSensitive:h,ignoreLocation:l},this.pattern=h?e:e.toLowerCase(),this.chunks=[],!this.pattern.length)return;const addChunk=(e,t)=>{this.chunks.push({pattern:e,alphabet:createPatternAlphabet(e),startIndex:t})},u=this.pattern.length;if(u>o){let e=0;const t=u%o,n=u-t;for(;e<n;)addChunk(this.pattern.substr(e,o),e),e+=o;if(t){const e=u-o;addChunk(this.pattern.substr(e),e)}}else addChunk(this.pattern,0)}searchIn(e){const{isCaseSensitive:t,includeMatches:n}=this.options;if(t||(e=e.toLowerCase()),this.pattern===e){let t={isMatch:!0,score:0};return n&&(t.indices=[[0,e.length-1]]),t}const{location:r,distance:i,threshold:s,findAllMatches:c,minMatchCharLength:o,ignoreLocation:a}=this.options;let h=[],l=0,u=!1;this.chunks.forEach((t=>{let{pattern:d,alphabet:g,startIndex:f}=t;const{isMatch:p,score:y,indices:m}=search(e,d,g,{location:r+f,distance:i,threshold:s,findAllMatches:c,minMatchCharLength:o,includeMatches:n,ignoreLocation:a});p&&(u=!0),l+=y,p&&m&&(h=[...h,...m])}));let d={isMatch:u,score:u?l/this.chunks.length:1};return u&&n&&(d.indices=h),d}}class BaseMatch{constructor(e){this.pattern=e}static isMultiMatch(e){return getMatch(e,this.multiRegex)}static isSingleMatch(e){return getMatch(e,this.singleRegex)}search(){}}function getMatch(e,t){const n=e.match(t);return n?n[1]:null}class FuzzyMatch extends BaseMatch{constructor(e){let{location:t=s.location,threshold:n=s.threshold,distance:r=s.distance,includeMatches:i=s.includeMatches,findAllMatches:c=s.findAllMatches,minMatchCharLength:o=s.minMatchCharLength,isCaseSensitive:a=s.isCaseSensitive,ignoreLocation:h=s.ignoreLocation}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(e),this._bitapSearch=new BitapSearch(e,{location:t,threshold:n,distance:r,includeMatches:i,findAllMatches:c,minMatchCharLength:o,isCaseSensitive:a,ignoreLocation:h})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(e){return this._bitapSearch.searchIn(e)}}class IncludeMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(e){let t,n=0;const r=[],i=this.pattern.length;for(;(t=e.indexOf(this.pattern,n))>-1;)n=t+i,r.push([t,n-1]);const s=!!r.length;return{isMatch:s,score:s?0:1,indices:r}}}const a=[class ExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(e){const t=e===this.pattern;return{isMatch:t,score:t?0:1,indices:[0,this.pattern.length-1]}}},IncludeMatch,class PrefixExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(e){const t=e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,this.pattern.length-1]}}},class InversePrefixExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(e){const t=!e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}},class InverseSuffixExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(e){const t=!e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}},class SuffixExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(e){const t=e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[e.length-this.pattern.length,e.length-1]}}},class InverseExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(e){const t=-1===e.indexOf(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}},FuzzyMatch],h=a.length,l=/ +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;const u=new Set([FuzzyMatch.type,IncludeMatch.type]);class ExtendedSearch{constructor(e){let{isCaseSensitive:t=s.isCaseSensitive,includeMatches:n=s.includeMatches,minMatchCharLength:r=s.minMatchCharLength,ignoreLocation:i=s.ignoreLocation,findAllMatches:c=s.findAllMatches,location:o=s.location,threshold:u=s.threshold,distance:d=s.distance}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.query=null,this.options={isCaseSensitive:t,includeMatches:n,minMatchCharLength:r,findAllMatches:c,ignoreLocation:i,location:o,threshold:u,distance:d},this.pattern=t?e:e.toLowerCase(),this.query=function parseQuery(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return e.split("|").map((e=>{let n=e.trim().split(l).filter((e=>e&&!!e.trim())),r=[];for(let e=0,i=n.length;e<i;e+=1){const i=n[e];let s=!1,c=-1;for(;!s&&++c<h;){const e=a[c];let n=e.isMultiMatch(i);n&&(r.push(new e(n,t)),s=!0)}if(!s)for(c=-1;++c<h;){const e=a[c];let n=e.isSingleMatch(i);if(n){r.push(new e(n,t));break}}}return r}))}(this.pattern,this.options)}static condition(e,t){return t.useExtendedSearch}searchIn(e){const t=this.query;if(!t)return{isMatch:!1,score:1};const{includeMatches:n,isCaseSensitive:r}=this.options;e=r?e:e.toLowerCase();let i=0,s=[],c=0;for(let r=0,o=t.length;r<o;r+=1){const o=t[r];s.length=0,i=0;for(let t=0,r=o.length;t<r;t+=1){const r=o[t],{isMatch:a,indices:h,score:l}=r.search(e);if(!a){c=0,i=0,s.length=0;break}if(i+=1,c+=l,n){const e=r.constructor.type;u.has(e)?s=[...s,...h]:s.push(h)}}if(i){let e={isMatch:!0,score:c/i};return n&&(e.indices=s),e}}return{isMatch:!1,score:1}}}const d=[];function createSearcher(e,t){for(let n=0,r=d.length;n<r;n+=1){let r=d[n];if(r.condition(e,t))return new r(e,t)}return new BitapSearch(e,t)}const g="$and",f="$or",p="$path",y="$val",isExpression=e=>!(!e[g]&&!e[f]),convertToExplicit=e=>({[g]:Object.keys(e).map((t=>({[t]:e[t]})))});function parse(e,t){let{auto:n=!0}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const next=e=>{let r=Object.keys(e);const i=(e=>!!e[p])(e);if(!i&&r.length>1&&!isExpression(e))return next(convertToExplicit(e));if((e=>!isArray(e)&&isObject(e)&&!isExpression(e))(e)){const s=i?e[p]:r[0],c=i?e[y]:e[s];if(!isString(c))throw new Error((e=>`Invalid value for key ${e}`)(s));const o={keyId:createKeyId(s),pattern:c};return n&&(o.searcher=createSearcher(c,t)),o}let s={children:[],operator:r[0]};return r.forEach((t=>{const n=e[t];isArray(n)&&n.forEach((e=>{s.children.push(next(e))}))})),s};return isExpression(e)||(e=convertToExplicit(e)),next(e)}function transformMatches(e,t){const n=e.matches;t.matches=[],isDefined(n)&&n.forEach((e=>{if(!isDefined(e.indices)||!e.indices.length)return;const{indices:n,value:r}=e;let i={indices:n,value:r};e.key&&(i.key=e.key.src),e.idx>-1&&(i.refIndex=e.idx),t.matches.push(i)}))}function transformScore(e,t){t.score=e.score}class Fuse{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2?arguments[2]:void 0;this.options=_objectSpread(_objectSpread({},s),t),this.options.useExtendedSearch,this._keyStore=new KeyStore(this.options.keys),this.setCollection(e,n)}setCollection(e,t){if(this._docs=e,t&&!(t instanceof FuseIndex))throw new Error("Incorrect 'index' type");this._myIndex=t||createIndex(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(e){isDefined(e)&&(this._docs.push(e),this._myIndex.add(e))}remove(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>!1;const t=[];for(let n=0,r=this._docs.length;n<r;n+=1){const i=this._docs[n];e(i,n)&&(this.removeAt(n),n-=1,r-=1,t.push(i))}return t}removeAt(e){this._docs.splice(e,1),this._myIndex.removeAt(e)}getIndex(){return this._myIndex}search(e){let{limit:t=-1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{includeMatches:n,includeScore:r,shouldSort:i,sortFn:c,ignoreFieldNorm:o}=this.options;let a=isString(e)?isString(this._docs[0])?this._searchStringList(e):this._searchObjectList(e):this._searchLogical(e);return function computeScore(e,t){let{ignoreFieldNorm:n=s.ignoreFieldNorm}=t;e.forEach((e=>{let t=1;e.matches.forEach((e=>{let{key:r,norm:i,score:s}=e;const c=r?r.weight:null;t*=Math.pow(0===s&&c?Number.EPSILON:s,(c||1)*(n?1:i))})),e.score=t}))}(a,{ignoreFieldNorm:o}),i&&a.sort(c),isNumber(t)&&t>-1&&(a=a.slice(0,t)),function format(e,t){let{includeMatches:n=s.includeMatches,includeScore:r=s.includeScore}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=[];return n&&i.push(transformMatches),r&&i.push(transformScore),e.map((e=>{const{idx:n}=e,r={item:t[n],refIndex:n};return i.length&&i.forEach((t=>{t(e,r)})),r}))}(a,this._docs,{includeMatches:n,includeScore:r})}_searchStringList(e){const t=createSearcher(e,this.options),{records:n}=this._myIndex,r=[];return n.forEach((e=>{let{v:n,i,n:s}=e;if(!isDefined(n))return;const{isMatch:c,score:o,indices:a}=t.searchIn(n);c&&r.push({item:n,idx:i,matches:[{score:o,value:n,norm:s,indices:a}]})})),r}_searchLogical(e){const t=parse(e,this.options),evaluate=(e,t,n)=>{if(!e.children){const{keyId:r,searcher:i}=e,s=this._findMatches({key:this._keyStore.get(r),value:this._myIndex.getValueForItemAtKeyId(t,r),searcher:i});return s&&s.length?[{idx:n,item:t,matches:s}]:[]}const r=[];for(let i=0,s=e.children.length;i<s;i+=1){const s=e.children[i],c=evaluate(s,t,n);if(c.length)r.push(...c);else if(e.operator===g)return[]}return r},n=this._myIndex.records,r={},i=[];return n.forEach((e=>{let{$:n,i:s}=e;if(isDefined(n)){let e=evaluate(t,n,s);e.length&&(r[s]||(r[s]={idx:s,item:n,matches:[]},i.push(r[s])),e.forEach((e=>{let{matches:t}=e;r[s].matches.push(...t)})))}})),i}_searchObjectList(e){const t=createSearcher(e,this.options),{keys:n,records:r}=this._myIndex,i=[];return r.forEach((e=>{let{$:r,i:s}=e;if(!isDefined(r))return;let c=[];n.forEach(((e,n)=>{c.push(...this._findMatches({key:e,value:r[n],searcher:t}))})),c.length&&i.push({idx:s,item:r,matches:c})})),i}_findMatches(e){let{key:t,value:n,searcher:r}=e;if(!isDefined(n))return[];let i=[];if(isArray(n))n.forEach((e=>{let{v:n,i:s,n:c}=e;if(!isDefined(n))return;const{isMatch:o,score:a,indices:h}=r.searchIn(n);o&&i.push({score:a,key:t,value:n,idx:s,norm:c,indices:h})}));else{const{v:e,n:s}=n,{isMatch:c,score:o,indices:a}=r.searchIn(e);c&&i.push({score:o,key:t,value:e,norm:s,indices:a})}return i}}Fuse.version="6.6.2",Fuse.createIndex=createIndex,Fuse.parseIndex=function parseIndex(e){let{getFn:t=s.getFn,fieldNormWeight:n=s.fieldNormWeight}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{keys:r,records:i}=e,c=new FuseIndex({getFn:t,fieldNormWeight:n});return c.setKeys(r),c.setIndexRecords(i),c},Fuse.config=s,Fuse.parseQuery=parse,function register(){d.push(...arguments)}(ExtendedSearch)},psT3:(e,t,n)=>{e.exports=n("2pFd")("Fx7m")}}]);